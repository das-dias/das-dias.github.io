<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="das-dias">
        <link rel="canonical" href="https://das-dias.github.io/signal_converters/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Signal-Converters - Diogo André Silvares Dias</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/night-owl.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Diogo André Silvares Dias</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../misc/" class="nav-link">Miscellaneous</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Signal-Converters</a>
                            </li>
                            <li class="navitem">
                                <a href="../computational_electromagnetics/" class="nav-link">Computational Electromagnetics</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../misc/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../computational_electromagnetics/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#signal-representation" class="nav-link">Signal Representation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#signal-representation-in-the-time-domain" class="nav-link">Signal Representation in the Time-Domain</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#signal-representation-in-the-frequency-domain" class="nav-link">Signal Representation in the Frequency-Domain</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#noise-sources-and-representation" class="nav-link">Noise Sources and Representation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#ideal-adc-and-dac-modelling" class="nav-link">Ideal ADC and DAC modelling</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#digital-to-analog-converter-modelling" class="nav-link">Digital-to-Analog Converter Modelling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#analog-to-digital-converter-modelling" class="nav-link">Analog-to-Digital Converter Modelling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#linear-and-non-linear-errors-in-dacs-and-adcs" class="nav-link">Linear and Non-linear Errors in DACs and ADCs</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#dac-errors-modelling" class="nav-link">DAC Errors Modelling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#adc-error-modelling" class="nav-link">ADC Error Modelling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#noise-modelling" class="nav-link">Noise modelling</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#jitter-noise-modelling" class="nav-link">Jitter Noise Modelling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#gaussian-noise-sources-thermal-noise" class="nav-link">Gaussian Noise Sources - Thermal Noise</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#quantization-noise-modelling" class="nav-link">Quantization Noise Modelling</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#total-output-noise" class="nav-link">Total Output Noise</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#modelling-of-resistive-dacs-at-element-level" class="nav-link">Modelling of Resistive DACs at element level</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#modelling-of-a-thermometer-code-dac" class="nav-link">Modelling of a Thermometer Code DAC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#modelling-of-a-binary-weighted-resistor-dac" class="nav-link">Modelling of a Binary Weighted Resistor DAC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="signal-representation">Signal Representation</h1>
<p>This practical class reviews some of the possible representations of a signal both in the time domain and in the frequency domain. All of the practical classes will take advantage of the Python programming language to study and model signal converters. The Jupyter Notebooks are a great way to segment the developed code, enabling an easier debugging and learning experience. The Jupyter Notebooks also enable the introduction of Markdown latex HTML notes in the middle of the code cells, offering a truly complete note-taking environment.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">scienceplots</span>

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">([</span><span class="s1">&#39;science&#39;</span><span class="p">,</span> <span class="s1">&#39;notebook&#39;</span><span class="p">])</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div>

<h2 id="signal-representation-in-the-time-domain">Signal Representation in the Time-Domain</h2>
<p align="justify"> This section covers some nuances of the represenation of a signal (voltage/current/code) in the time-domain, throughout an independent axis representing time. Two main aspects of the representation of a signal are presented:
<ul>
<li>1- A signal can be decomposed on an infinite sum of fundamental trigonometric functions (sine and cosine), according to Fourier's Signal Theory;</li>
<li>2- The importance of using a differential signal chain is analysed to observe its impact on the overall distortion of the output signal.</li>
</ul>
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the number of points for the simulation</span>
<span class="c1"># NOTE: This enables a better control of the simulation time and memmory resources </span>
<span class="n">Np</span> <span class="o">=</span> <span class="mi">1001</span>
<span class="c1"># define time base</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="mf">100e3</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span>
<span class="n">tD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Ts</span><span class="p">;</span> <span class="c1"># (0:Np-1) == np.arange(0,Np)</span>
<span class="n">tD</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the signals</span>
<span class="n">Amp1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f1</span> <span class="o">=</span> <span class="mf">1e3</span>
<span class="n">phase1</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">phase1_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phase1</span><span class="p">)</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">Amp1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f1</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">phase1_rad</span><span class="p">)</span>
<span class="n">x1</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># visualize the signals</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_5_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># changing the frequency of the signal</span>
<span class="c1"># define the new signal</span>
<span class="n">Amp2</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f2</span> <span class="o">=</span> <span class="mf">0.5e3</span>
<span class="n">phase2</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">phase2_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phase1</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">Amp2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f2</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">phase1_rad</span><span class="p">)</span>
<span class="n">x2</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># visualize the signals</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_7_1.png" />  </p>
<div class="codehilite"><pre><span></span><code><span class="c1"># observing 2 sinusoids in the same plot</span>
<span class="c1"># second harmonic </span>
<span class="n">Amp2</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">f2</span> <span class="o">=</span> <span class="mf">2e3</span>
<span class="n">phase2_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">Amp2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f2</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">phase2_rad</span><span class="p">)</span>
<span class="c1"># third harmonic</span>
<span class="n">Amp3</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">f3</span> <span class="o">=</span> <span class="mf">3e3</span>
<span class="n">phase3_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">Amp3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f3</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">phase3_rad</span><span class="p">)</span>
</code></pre></div>

<p>Visualize the signals and infer on the veracity of the Fourier Series 
representation of the signal - any signal can be represented as a sum of sinusoids!
In this case, the sum of x1 with x3 can almost generate a digital signal denominated as a square wave.</p>
<div class="codehilite"><pre><span></span><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;x1&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;x2&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;x3&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;x1(t), x3(t)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;pink&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x1</span><span class="o">+</span><span class="n">x2</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;x1(t) + x2(t)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">x1</span><span class="o">+</span><span class="n">x3</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;x1(t) + x3(t)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_10_0.png" /></p>
<p align="justify">
From the above signal representations, two conclusions can be made:
<ul>
<li>The odd harmonics allow to preserve the area ratio of the positive wave and negative wave of the signal in relation to the average value.In other words, the odd harmonics allow the signal to preserve its symmetry.
</li> 
<li>The same is not true for the even harmonics. The even harmonics do not ensure that the signal preserves its symmetry in relation to its average value.
</li>
</ul>
</p>

<p align="justify">
Any signal processing chain, or signal conversion chain should always be differential, in which the processed signals feature a phase of 180 º between each other. Differential signals enable the natural cancellation of the even harmonic components of the signal, significantly improving the linearity of the signal at the output of the signal processign chain.
</p>

<p>Demo:<br />
Given the signal:</p>
<p>$$ s(t) = a_1 <em>sin(2\pi f_1t + \phi_1 ) + (a_2</em>sin(2\pi f_1t + \phi_2 ))^2 + (a_3 *sin(2\pi f_1t + \phi_3 ))^3 $$</p>
<p>where: $f_2 = 2f_1$ and $f_3=3f_1$</p>
<p>The differential rendition of this signal would give us:</p>
<p>$$ s(t) - s(t+180º) = 2a_1<em>sin(2\pi f_1t + \phi_1) + \frac{4a_3^2}{3}</em>sin(2\pi 3f_1t + \phi_3) + s_{DC} $$</p>
<p align="justify">
As it is possible to observe, the even harmonic components are cancelled, and thus the distortion is reduced.
</p>

<hr />
<h2 id="signal-representation-in-the-frequency-domain">Signal Representation in the Frequency-Domain</h2>
<p align="justify"> 
This section covers the representation of the signals defined in the previous section in the frequency domain. The signal representation defined by Fourier's series holds true in the frequency spectrum. A depiction of this is the representation of the sum of the x1, x2 and x3 signals in the frequency spectrum, featuring the resulting three dirac distributions. The frequencies of these distributions correspond to the fundamental, second and third harmonics of the signal resulting from the sum of the signals.
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># spectral analysis using fft - fast fourier transform</span>
<span class="n">yt</span> <span class="o">=</span> <span class="n">x1</span><span class="o">+</span><span class="n">x2</span><span class="o">+</span><span class="n">x3</span>
<span class="n">yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">yt</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>  <span class="c1"># [V] # voltage in the frequency axis</span>
<span class="c1"># NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform</span>
<span class="n">fD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span> <span class="n">Ts</span><span class="p">))</span>  <span class="c1"># [Hz] # frequency axis</span>
<span class="n">power_yf</span> <span class="o">=</span> <span class="p">(</span><span class="n">yf</span><span class="o">*</span><span class="n">yf</span><span class="p">)</span> <span class="c1"># [V^2] - square the voltage spectrum to obtain the power spectrum</span>
<span class="n">power_yf_dB</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">power_yf</span><span class="p">)</span>  <span class="c1"># [dB] - convert the power spectrum to dB</span>
<span class="n">power_yf_dB</span>

<span class="n">yf2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>  <span class="c1"># [V] # voltage in the frequency axis</span>
<span class="c1"># NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform</span>
<span class="n">power_yf2</span> <span class="o">=</span> <span class="p">(</span><span class="n">yf2</span><span class="o">*</span><span class="n">yf2</span><span class="p">)</span> <span class="c1"># [V^2] - square the voltage spectrum to obtain the power spectrum</span>
<span class="n">power_yf2_dB</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">power_yf2</span><span class="p">)</span>  <span class="c1"># [dB] - convert the power spectrum to dB</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the frequency spectrum</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">f_scale</span> <span class="o">=</span> <span class="mf">1e3</span><span class="c1"># frequency scale [Hz]</span>
<span class="n">p_scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># power scale in [dB]</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span>
    <span class="n">power_yf_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">bottom</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">power_yf_dB</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">),</span>
    <span class="c1">#use_line_collection=True,</span>
    <span class="n">linefmt</span><span class="o">=</span><span class="s2">&quot;b-&quot;</span><span class="p">,</span>
    <span class="n">markerfmt</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">basefmt</span><span class="o">=</span><span class="s2">&quot;r-&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Frequency spectrum of x1+x2+x3&quot;</span><span class="p">)</span>
<span class="n">f_lim</span> <span class="o">=</span> <span class="mf">4e3</span><span class="o">/</span><span class="n">f_scale</span> <span class="c1"># limitting frequency</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">f_lim</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span>
    <span class="n">power_yf2_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span>
<span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">f_lim</span><span class="p">])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_14_0.png" /></p>
<p align="justify">
As it is possible to observe, the plot of x1 in black (the second curve) gives us a spectral dirac that is not concentrated on a single frequency bin, and rather spreads throughout the frequency with decreasing power throughout the spectrum.
</p>

<h3 id="one-possible-solution-windows">One possible solution: Windows!</h3>
<p align="justify">
The use of a window defining the simulation time window in which the spectrum of the signal will be analysed can significantly improve the spectral quality of the observed signal in the frequency spectrum. The following example uses a Blackman-Harris window, multiplying it to the signal in the time-domain. As such, the obtained signal's frequency spectrum features a much more perceptible definition of the central frequency of each signal's harmonic. The resulting computed spectral power of each harmonic appears to be lower than the spectrum obtained without the use of a window. This is a mere appearance, and it results from the fact that the Blackman-Harris window causes the power of each harmonic to be spread throughout 5 frequency bins (2 bins before, the central bin of the harmonic and 2 bins after).
</p>

<p align="justify">NOTE: Another solution (which is actually preferred) would be to use coherent sampling - ensuring the sampling frequency is simultaneously a prime number and a multiple of the input signal's frequency. Both solutions can also be used simultaneously.</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># applying a blackman harris window to</span>
<span class="c1"># better observe the signal&#39;s spectrum</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">blackmanharris</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Samples&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Window Amplitude&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_16_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># spectral analysis using fft - fast fourier transform</span>
<span class="n">ytbm</span> <span class="o">=</span> <span class="n">yt</span><span class="o">*</span><span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">blackmanharris</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span>
<span class="n">yfbm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">ytbm</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>  <span class="c1"># [V] # voltage in the frequency axis</span>
<span class="c1"># NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform</span>
<span class="n">power_yfbm</span> <span class="o">=</span> <span class="p">(</span><span class="n">yfbm</span><span class="o">*</span><span class="n">yfbm</span><span class="p">)</span> <span class="c1"># [V^2] - square the voltage spectrum to obtain the power spectrum</span>
<span class="n">power_yfbm_dB</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">power_yfbm</span><span class="p">)</span>  <span class="c1"># [dB] - convert the power spectrum to dB</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the frequency spectrum</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">f_scale</span> <span class="o">=</span> <span class="mf">1e3</span><span class="c1"># frequency scale [Hz]</span>
<span class="n">p_scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># power scale in [dB]</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span>
    <span class="n">power_yf_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">bottom</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">power_yf_dB</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">),</span>
    <span class="c1">#use_line_collection=True,</span>
    <span class="n">linefmt</span><span class="o">=</span><span class="s2">&quot;b-&quot;</span><span class="p">,</span>
    <span class="n">markerfmt</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">basefmt</span><span class="o">=</span><span class="s2">&quot;r-&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Frequency spectrum of x1+x2+x3&quot;</span><span class="p">)</span>
<span class="n">f_lim</span> <span class="o">=</span> <span class="mf">4e3</span><span class="o">/</span><span class="n">f_scale</span> <span class="c1"># limitting frequency</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">f_lim</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span>
    <span class="n">power_yf_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span>
    <span class="n">power_yfbm_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">f_lim</span><span class="p">])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_18_0.png" /></p>
<h2 id="noise-sources-and-representation">Noise Sources and Representation</h2>
<p align="justify">
To perform a more accurate simulation of the signal converters that are going to be studied in this course, a superposition of noise to the processed signal is inevitable and required. The process of quantizing an ideal signal without any supperposed noise will inevitably add a quantization error to the signal, as seen in the following equation.
</p>

<p>$$ s_Q(t) = s(t) + \epsilon_Q(t) \hspace{10pt} (1) $$</p>
<p>where $\epsilon_Q(t)$ is the quantization error, $s_Q(t)$ is the quantized signal and $s(t)$ is the processed signal.</p>
<p align="justify">
However, in reality all analog signals are subject to some form of noise. If the processed signal features a given level of noise power superposed to it, and the signal converter/quantizer features an high-enough quantization precision, the quantization error can actually be well approximated by white noise, as seen in (2). White noise is present throughout all the spectrum of both the signal and the quantizing system. It features a constant power spectral density throughout the system's operation spectrum, and as such it is very easy to model through a uniform distribution.
</p>

<p>$$ s_Q(t) = (x(t) + n(t)) + \epsilon_Q(t) = x(t) + v_{NQ}(t) \hspace{10pt} (2) $$</p>
<p>where $x(t)$ is the processed signal, $n(t)$ is the noise superposed to the processed signal and $v_{NQ}(t)$ is the quantization white noise approximated by the sum of $n(t)$ and $\epsilon_Q(t)$.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">normal</span><span class="p">,</span> <span class="n">uniform</span> <span class="c1"># random numbers fitted into a normal or uniform distribution</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span> <span class="c1"># to observe the noise signal&#39;s histogram</span>
<span class="c1"># define the quantizer&#39;s main parameters</span>
<span class="n">nbits</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># number of bits</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="c1"># reference voltage [V]</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span> <span class="c1"># fundamental step votlage of the quantizer [V]</span>
<span class="c1"># define the noise parameters</span>
<span class="n">vqmean</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># quantizer&#39;s mean voltage [V]</span>
<span class="n">vqvar</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlsb</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span> <span class="c1"># quantization noise variance  [V]</span>
<span class="n">vqstddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vqvar</span><span class="p">)</span> <span class="c1"># quantization noise standard deviation (Vqrms) [V]</span>
<span class="c1"># generate the noise signal</span>
<span class="n">vq</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">vqstddev</span><span class="p">,</span> <span class="n">vqstddev</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span> <span class="c1"># quantization noise signal with a uniform dist (white noise)[V]</span>
<span class="c1">#sns.distplot(vq, bins=10, hist_kws={&quot;edgecolor&quot;:&quot;black&quot;})</span>
<span class="c1"># frequency domain analysis of the white noise signal</span>
<span class="n">vqf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">vq</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>  <span class="c1"># [V] # voltage in the frequency axis</span>
<span class="n">pqf</span> <span class="o">=</span> <span class="p">(</span><span class="n">vqf</span><span class="o">*</span><span class="n">vqf</span><span class="p">)</span> <span class="c1"># [V^2] - square the voltage spectrum to obtain the power spectrum</span>
<span class="n">pqf_dB</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pqf</span><span class="p">)</span>  <span class="c1"># [dB] - convert the power spectrum to dB</span>
<span class="c1"># plot the frequency spectrum</span>
<span class="c1"># plot the noise signal in the time domain, frequency domain </span>
<span class="c1"># and its histogram</span>


<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">vq</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantization noise signal&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> 
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span> <span class="n">pqf_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantization noise signal&#39;s frequency spectrum&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span>
    <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> 
    <span class="n">xmin</span><span class="o">=-</span><span class="n">vqstddev</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">vqstddev</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantization noise signal&#39;s histogram&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_20_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># define the noise parameters</span>
<span class="n">vqmean</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># quantizer&#39;s mean voltage [V]</span>
<span class="n">vqvar</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlsb</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span> <span class="c1"># quantization noise variance  [V]</span>
<span class="n">vqstddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vqvar</span><span class="p">)</span> <span class="c1"># quantization noise standard deviation (Vqrms) [V]</span>
<span class="c1"># generate the noise signal</span>
<span class="n">vq</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">vqmean</span><span class="p">,</span> <span class="n">vqstddev</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span> <span class="c1"># gaussian noise signal with a normal dist [V]</span>
<span class="c1">#sns.distplot(vq, bins=10, hist_kws={&quot;edgecolor&quot;:&quot;black&quot;})</span>
<span class="c1"># frequency domain analysis of the white noise signal</span>
<span class="n">vqf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">vq</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>  <span class="c1"># [V] # voltage in the frequency axis</span>
<span class="n">pqf</span> <span class="o">=</span> <span class="p">(</span><span class="n">vqf</span><span class="o">*</span><span class="n">vqf</span><span class="p">)</span> <span class="c1"># [V^2] - square the voltage spectrum to obtain the power spectrum</span>
<span class="n">pqf_dB</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pqf</span><span class="p">)</span>  <span class="c1"># [dB] - convert the power spectrum to dB</span>
<span class="c1"># plot the frequency spectrum</span>
<span class="c1"># plot the noise signal in the time domain, frequency domain </span>
<span class="c1"># and its histogram</span>

<span class="c1">#! OBSERVE A NOISE SIGNAL DEFINED USNG A NORMAL DISTRIBUTION</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">vq</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gaussian noise signal&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> 
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span> <span class="n">pqf_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gaussian noise signal&#39;s frequency spectrum&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">vq</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#ax[2].vlines(</span>
<span class="c1">#    x=np.mean(vq), </span>
<span class="c1">#    ymin=0, ymax=np.mean(np.histogram(vq, bins=10)[0]), color=&quot;r&quot;)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gaussian noise signal&#39;s histogram&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_21_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># let us now superpose the noise signal to the x1 signal and observe </span>
<span class="c1"># the resulting signal&#39;s frequency spectrum, histogram and time domain</span>
<span class="n">Amp1</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># amplitude of the sine wave [V]</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">Amp1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f1</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">phase1_rad</span><span class="p">)</span> <span class="c1"># [V] - sine wave</span>
<span class="n">vq</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">vqstddev</span><span class="p">,</span> <span class="n">vqstddev</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span> <span class="c1"># quantization noise signal with a uniform dist (white noise)[V]</span>
<span class="n">st</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">vq</span>
<span class="n">stf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>  <span class="c1"># [V] # voltage in the frequency axis</span>
<span class="n">ptf</span> <span class="o">=</span> <span class="p">(</span><span class="n">stf</span><span class="o">*</span><span class="n">stf</span><span class="p">)</span> <span class="c1"># [V^2] - square the voltage spectrum to obtain the power spectrum</span>
<span class="n">ptf_dB</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ptf</span><span class="p">)</span>  <span class="c1"># [dB] - convert the power spectrum to dB</span>
<span class="c1"># plot the frequency spectrum</span>
<span class="c1"># plot the noise signal in the time domain, frequency domain</span>
<span class="c1"># and its histogram</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Quantized signal - $s(t)$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">f_scale</span><span class="p">,</span> <span class="n">ptf_dB</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p_scale</span><span class="p">,</span>
    <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantized signal&#39;s frequency spectrum&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Voltage (V)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantized signal&#39;s histogram&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_1_files/practical_class_1_22_0.png" /></p>
<hr />
<h1 id="ideal-adc-and-dac-modelling">Ideal ADC and DAC modelling</h1>
<p align="justify">
The models of an ideal ADC and DAC biased with a Vref voltage and N bits of resolution are presented in this notebook. The covnersion functions of both converters were created using the lambda programming style. Using this style, the creator function for the ADC or DAC receives the 2 fundamental parameters defining these ideal electronic systems:
<ul>
<li>Vref - The reference/biasing voltage of the converter;</li>
<li>Nbits - the number of bits of the converter system (its digital resolution).</li>
</ul>
The converter then returns a function that depending on its input will generate an output code or voltage, for the ADC or DAC, respectively.
</p>

<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">scienceplots</span>

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">([</span><span class="s1">&#39;science&#39;</span><span class="p">,</span> <span class="s1">&#39;notebook&#39;</span><span class="p">])</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the function to convert a binary vector to decimal</span>
<span class="k">def</span> <span class="nf">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a numpy array from binary to decimal.</span>
<span class="sd">    IF the input is an array of binary arrays, </span>
<span class="sd">    the returned output is an array of the corresponding </span>
<span class="sd">    decimals in their corresponding indexes.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        x: numpy array</span>
<span class="sd">        b: base of the number system</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">width</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">width</span><span class="p">,</span> <span class="s2">&quot;The length of the vector must be equal to the number of bits&quot;</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">width</span><span class="p">,</span> <span class="s2">&quot;The length of the vector must be equal to the number of bits&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xval</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">xval</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">xval</span><span class="p">)</span> <span class="k">for</span> <span class="n">xval</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">dec2bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a numpy array from decimal to binary</span>
<span class="sd">    If the input is an array of decimals, the returned </span>
<span class="sd">    binary arrays are the codes corresponding to </span>
<span class="sd">    each decimal in its corresponding index.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        x: numpy array</span>
<span class="sd">        b: base of the number system</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">subx</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)])</span> <span class="k">for</span> <span class="n">subx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>

<span class="c1"># test </span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">45</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>

<h2 id="digital-to-analog-converter-modelling">Digital-to-Analog Converter Modelling</h2>
<p align="justify"> 
This section presents the definition of the ideal model for the 
transfer function of a DAC. The corresponding transfer function 
that is implemented through a lambda programming style can be observed
in (1). There are other possible solutions, such as using an 
object-oriented programming approach by defining a DAC object with 
a "convert" method.
</p>

<p>$$ V_{OUT}(D_{in}) = base_{10}{D_{in}}*V_{LSB}\hspace{10 pt} (1) $$</p>
<p>where $D_{in}$ is the input binary word of the DAC, $V_{LSB}$ is the Least Significant Bit step voltage and $V_{OUT}$ is the output voltage of the DAC.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Modelling an ideal Digital to Analog Converter (DAC)</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># The biasing voltage of the DAC [V]</span>
<span class="n">n_bits</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># The resolution of the ideal DAC</span>
<span class="c1"># define the ideal model of a DAC using lambda programming</span>
<span class="k">def</span> <span class="nf">ideal_dac</span><span class="p">(</span><span class="n">vref</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define the transfer function of an ideal </span>
<span class="sd">    DAC biased by vref and presenting an n_bits resolution.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        vref (float): The biasing voltage of the electronic system.</span>
<span class="sd">        n_bits (int): The resolution of the DAC.</span>
<span class="sd">    Returns:</span>
<span class="sd">        function(Din): the lambda function defining the transfer function of the DAC</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span> <span class="c1"># compute the fundamental step voltage between quantized levels</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span><span class="o">*</span><span class="n">vlsb</span> <span class="c1"># return the converter funtion</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the DAC&#39;s transfer function</span>
<span class="n">idac</span> <span class="o">=</span> <span class="n">ideal_dac</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># define the array of decimal input codes</span>
<span class="c1"># belonging to [0, 2^{n_bits}-1]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># convert the input codes array </span>
<span class="c1"># from decimal to binary using arrays of 1s and 0s</span>
<span class="n">x_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dec2bin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
<span class="c1"># create the string representation of the binary words</span>
<span class="n">x_bin_str</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">])</span> <span class="k">for</span> <span class="n">xv</span> <span class="ow">in</span> <span class="n">x_bin</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x_bin</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">idac</span><span class="p">(</span><span class="n">x_bin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="c1"># get the corresponding output voltages</span>
<span class="c1"># of the DAC for each corresponding input code</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">idac</span><span class="p">(</span><span class="n">x_bin</span><span class="p">)</span>
<span class="c1"># plot the transfer function of the ideal DAC</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_bin_str</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">)</span> <span class="c1"># mfc == marker face color</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">x_bin_str</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Code&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Ideal DAC Transfer Function (Vout(Din))&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">x_bin_str</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;floor&quot;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">)</span>
<span class="c1"># note that the step function of the DAC is always a post step!</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">x_bin_str</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Code&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">[0 1 2 3 4 5 6 7]</span><span class="w"></span>
<span class="k">[[0 0 0]</span><span class="w"></span>
<span class="w"> </span><span class="k">[0 0 1]</span><span class="w"></span>
<span class="w"> </span><span class="k">[0 1 0]</span><span class="w"></span>
<span class="w"> </span><span class="k">[0 1 1]</span><span class="w"></span>
<span class="w"> </span><span class="k">[1 0 0]</span><span class="w"></span>
<span class="w"> </span><span class="k">[1 0 1]</span><span class="w"></span>
<span class="w"> </span><span class="k">[1 1 0]</span><span class="w"></span>
<span class="w"> </span><span class="k">[1 1 1]]</span><span class="w"></span>
<span class="na">0.625</span><span class="w"></span>


<span class="na">/var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:20: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.</span><span class="w"></span>
<span class="w">  </span><span class="na">ax[0].set_xticklabels(x_bin_str, rotation</span><span class="o">=</span><span class="s">45)</span><span class="w"></span>
<span class="na">/var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:28: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.</span><span class="w"></span>
<span class="w">  </span><span class="na">ax[1].set_xticklabels(x_bin_str, rotation</span><span class="o">=</span><span class="s">45)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_2_files/practical_class_2_5_2.png" /></p>
<h2 id="analog-to-digital-converter-modelling">Analog-to-Digital Converter Modelling</h2>
<p align="justify"> 
This section presents the definition of the ideal model for the 
transfer function of a ADC. The corresponding transfer function 
that is implemented through a lambda programming style can be observed
in (2). Once again, there are other possible solutions, such as using an 
object-oriented programming approach by defining a DAC object with 
a "convert" method.
</p>

<p>$$ D_{OUT}(V_{in}, f_{Round}) = base_2{f_{Round}(V_{in}/V_{LSB})} \hspace{10 pt} (2) $$</p>
<p>where $V_{in}$ is the input voltage of the ADC, $V_{LSB}$ is the Least Significant Bit step voltage and $D_{OUT}$ is the output digital code of the ADC. $f_{Round}$ is the rounding function that the ADC implements in practice, and this function can be one of three possible solutions: </p>
<ul>
<li>a) round(.), rounding to the nearest decimal;</li> 
<li>b) ceil(.), rounding to the highest decimal;</li> 
<li>c) floor(.), rounding to the lowest decimal.</li>
</ul>

<p align="justify">
In this case, equation (2) defines an ADC transfer function that returns the output code in the form of a binary digital word, to provide consistency with the presented code below. It is important to note that the the rounding function is parsed as an input to the 
ADC's transfer function for practical, low-code purposes.
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># modelling an ideal ADC</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># V</span>
<span class="n">n_bits</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># bits</span>
<span class="k">def</span> <span class="nf">ideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">nbits</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">roundf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define the transfer function of an ideal </span>
<span class="sd">    ADC biased by vref and presenting an n_bits resolution.</span>
<span class="sd">    Parameters:</span>
<span class="sd">        vref (float): The biasing voltage of the electronic system.</span>
<span class="sd">        n_bits (int): The resolution of the DAC.</span>
<span class="sd">        roundf (function): The rounding function to be used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        function(Vin): the lambda function defining the transfer function of the ADC</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">roundf</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">],</span> <span class="s2">&quot;The round function must be numpy.floor, numpy.ceil or numpy.round&quot;</span>
    <span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">roundf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">nbits</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">iadc</span> <span class="o">=</span> <span class="n">ideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">)</span>
<span class="n">iadc_ceil</span> <span class="o">=</span> <span class="n">ideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
<span class="n">iadc_floor</span> <span class="o">=</span> <span class="n">ideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">iadc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span><span class="n">vref</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">iadc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_str</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">yv</span><span class="p">])</span> <span class="k">for</span> <span class="n">yv</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_str</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_str</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Code&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_str</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;mid&quot;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">iadc_ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_str</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">yv</span><span class="p">])</span> <span class="k">for</span> <span class="n">yv</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_str</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ceil&quot;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Code&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">iadc_floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_str</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">yv</span><span class="p">])</span> <span class="k">for</span> <span class="n">yv</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_str</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;floor&quot;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;pre&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Code&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">vref</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">vref</span><span class="p">])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dout(Vin)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="k">[[0 0 0]</span><span class="w"></span>
<span class="w"> </span><span class="k">[0 1 0]</span><span class="w"></span>
<span class="w"> </span><span class="k">[0 1 1]</span><span class="w"></span>
<span class="w"> </span><span class="k">[1 0 1]</span><span class="w"></span>
<span class="w"> </span><span class="k">[1 1 0]]</span><span class="w"></span>
<span class="k">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_2_files/practical_class_2_8_1.png" /></p>
<hr />
<h1 id="linear-and-non-linear-errors-in-dacs-and-adcs">Linear and Non-linear Errors in DACs and ADCs</h1>
<p align="justify">
The introduction of quantization noise in the ADC or DAC introduces errors 
associated with the quantization step size defining the true characteristic 
of the ADC or DAC transfer function. This notebook presents the modelling and 
study of the two main types of errors in converters: linear and non-linear.
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># mathematical computing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span> <span class="c1"># to generate the noise signal</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span> <span class="c1"># to observe the noise signal&#39;s histogram</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">normal</span> <span class="c1"># random numbers fitted into a uniform distribution</span>
<span class="c1"># plotting</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># import the models and utilities functions</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">ideal_dac</span><span class="p">,</span> <span class="n">ideal_adc</span><span class="p">,</span> <span class="n">nonideal_adc</span><span class="p">,</span> <span class="n">dec2bin</span><span class="p">,</span> <span class="n">bin2dec</span>

<span class="kn">import</span> <span class="nn">scienceplots</span>

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">([</span><span class="s1">&#39;science&#39;</span><span class="p">,</span> <span class="s1">&#39;notebook&#39;</span><span class="p">])</span>
</code></pre></div>

<h2 id="dac-errors-modelling">DAC Errors Modelling</h2>
<h3 id="dac-linear-errors">DAC Linear Errors</h3>
<p align="justify"> 
This section presents the modelling of the linear errors that arise when modelling the transfer function of a DAC. These errors relate to a deviation of the real transfer function of the DAC towards the ideal DAC's transfer function, in which each step size is exactly the same height!
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the DAC </span>
<span class="n">vref</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define the reference voltage [V]</span>
<span class="n">n_bits</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># define the number of bits of the DAC</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span> <span class="c1"># compute the fundamental step voltage between quantized levels</span>
<span class="c1"># define an ideal DAC to compare the results</span>
<span class="n">idac</span> <span class="o">=</span> <span class="n">ideal_dac</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># define a DAC with offset error</span>
<span class="n">voff</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">dac_off</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">idac</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">voff</span>
<span class="c1"># define a DAC with end of scale error</span>
<span class="c1"># note that the end of scale error </span>
<span class="c1"># is actually directly related to</span>
<span class="c1"># the gain error of the DAC</span>
<span class="n">gain_err</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>
<span class="n">target_gain</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">gain_err</span>
<span class="n">dac_eos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">idac</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">target_gain</span>
<span class="c1"># define a DAC with offset and end of scale error</span>
<span class="c1"># to measure the true DAC gain error</span>
<span class="n">dac_off_eos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">idac</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">target_gain</span> <span class="o">+</span> <span class="n">voff</span>
<span class="c1"># define the input codes of the 3 DACs</span>
<span class="n">din</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># convert the decimals to input binary words</span>
<span class="n">dinb</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">din</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># create the string representation of the input codes</span>
<span class="n">dinb_str</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">])</span> <span class="k">for</span> <span class="n">xv</span> <span class="ow">in</span> <span class="n">dinb</span><span class="p">]</span>
<span class="c1"># compute the output voltages of the 3 DACs</span>
<span class="n">vout</span> <span class="o">=</span> <span class="n">idac</span><span class="p">(</span><span class="n">dinb</span><span class="p">)</span>
<span class="n">vout_off</span> <span class="o">=</span> <span class="n">dac_off</span><span class="p">(</span><span class="n">dinb</span><span class="p">)</span>
<span class="n">vout_eos</span> <span class="o">=</span> <span class="n">dac_eos</span><span class="p">(</span><span class="n">dinb</span><span class="p">)</span>
<span class="n">vout_off_eos</span> <span class="o">=</span> <span class="n">dac_off_eos</span><span class="p">(</span><span class="n">dinb</span><span class="p">)</span>
</code></pre></div>

<p align="justify">
To accurately measure the linear error of DACs it is only necessary to observe the initial and final points of the transfer function. From these points three measurements can be performed:
<ul>
<li>Offset Error, represented in Eq.(1)</li>
<li>End of Scale Error, represented in Eq.(2)</li>
<li>Gain Error, represented in Eq.(3)</li>
</ul>

The Gain Error of the DAC is directly related to both the End of Scale and Offset Errors of the DAC and is derived from them. The errors are measured in LSB units.
</p>

<p>$$ \epsilon_{OFF} = \frac{V_{OUT}'[T_0] - V_{OUT}[T_0]}{V_{LSB}} \hspace{4 pt} [LSB] \hspace{10 pt} (1) $$</p>
<p>$$ \epsilon_{EOS} = \frac{V_{OUT}'[T_{2^N - 1}] - V_{OUT}[T_{2^N - 1}]}{V_{LSB}} \hspace{4 pt} [LSB] \hspace{10 pt} (2) $$</p>
<p>$$ GER_{[\%]} = \left(\frac{V_{OUT}'[T_{2^N - 1}] - V_{OUT}'[T_{0}]}{V_{OUT}[T_{2^N - 1}] - V_{OUT}[T_{0}]} - 1\right)\times100 \hspace{10 pt} (3) $$</p>
<p>where $V_{OUT}[T_i]$ and $V_{OUT}'[T_i]$ is the output voltage of the ideal DAC and real DAC at the $i^{th}$ transition, respectively.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># measure the DAC errors</span>
<span class="n">eoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb</span>
<span class="n">eeos</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb</span>
<span class="n">ger_pct</span> <span class="o">=</span> <span class="p">((</span><span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">vout</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The offset error is </span><span class="si">{:.2f}</span><span class="s2"> LSB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eoff</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The end of scale error is </span><span class="si">{:.2f}</span><span class="s2"> LSB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eeos</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The gain error is </span><span class="si">{:.2f}</span><span class="s2"> %&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ger_pct</span><span class="p">))</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nv">The</span><span class="w"> </span><span class="nv">offset</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="mi">1</span>.<span class="mi">60</span><span class="w"> </span><span class="nv">LSB</span><span class="w"></span>
<span class="nv">The</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>.<span class="mi">50</span><span class="w"> </span><span class="nv">LSB</span><span class="w"></span>
<span class="nv">The</span><span class="w"> </span><span class="nv">gain</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="o">-</span><span class="mi">10</span>.<span class="mi">00</span><span class="w"> </span><span class="o">%</span><span class="w"></span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">din</span><span class="p">,</span><span class="n">vout</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ideal DAC&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">din</span><span class="p">,</span><span class="n">vout_off</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DAC w/ offset error&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">din</span><span class="p">,</span><span class="n">vout_eos</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DAC w/ end of scale error&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">din</span><span class="p">,</span><span class="n">vout_off_eos</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DAC w/ offset &amp; end of scale error&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Input code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output voltage [V]&quot;</span><span class="p">)</span>
<span class="c1">#ax.set_xticks(din)</span>
<span class="c1">#ax.set_xticklabels(dinb_str, rotation=45)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;DAC Transfer Function&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># annotate the DAC errors on the plot</span>
<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\epsilon_</span><span class="si">{OFF}</span><span class="s2">$: &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> LSB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eoff</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\epsilon_</span><span class="si">{EOS}</span><span class="s2">$: &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> LSB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eeos</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="c1"># add an arrow showing the difference between the ideal DAC and the DAC with offset and end of scale error</span>
<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;Gain error: </span><span class="si">{:.2f}</span><span class="s2"> %&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ger_pct</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_3_files/practical_class_3_6_0.png" /></p>
<h3 id="dac-non-linear-errors">DAC Non-Linear Errors</h3>
<p align="justify"> 
This section presents the modelling of the non-linear errors that arise when modelling the transfer function of a DAC. These errors relate to a deviation of the real transfer function of the DAC towards the ideal DAC's transfer function, in which each step size can differ in height due to the inherent non-linearity that arises when quantizing a noisy signal!
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the DAC </span>
<span class="n">vref</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define the reference voltage [V]</span>
<span class="n">n_bits</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># define the number of bits of the DAC</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span> <span class="c1"># compute the fundamental step voltage between quantized levels</span>
<span class="c1"># define an ideal DAC to compare the results</span>
<span class="n">idac</span> <span class="o">=</span> <span class="n">ideal_dac</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># define the noise signal with a uniform distribution</span>
<span class="n">vq_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlsb</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span>
<span class="n">vq_std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vq_var</span><span class="p">)</span>
<span class="n">noise_factor</span><span class="o">=</span><span class="mi">2</span>
<span class="n">dac_nonlinear</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">idac</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise_factor</span><span class="o">*</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">vq_std_dev</span><span class="p">,</span> <span class="n">vq_std_dev</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1">#dac_nonlinear = lambda x: idac(x) + normal(loc=0, scale=vq_std_dev, size=len(x))</span>
<span class="c1"># define the input codes of the DAC</span>
<span class="n">din</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># convert the decimals to input binary words</span>
<span class="n">dinb</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">din</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="c1"># create the string representation of the input codes</span>
<span class="n">dinb_str</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">])</span> <span class="k">for</span> <span class="n">xv</span> <span class="ow">in</span> <span class="n">dinb</span><span class="p">]</span>
<span class="c1"># compute the output voltages of the DAC</span>
<span class="n">vout</span> <span class="o">=</span> <span class="n">idac</span><span class="p">(</span><span class="n">dinb</span><span class="p">)</span>
<span class="n">vout_nonlinear</span> <span class="o">=</span> <span class="n">dac_nonlinear</span><span class="p">(</span><span class="n">dinb</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">din</span><span class="p">,</span><span class="n">vout</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ideal DAC&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="c1">#ax.step(din,vout, where=&quot;post&quot;, label=&quot;Ideal DAC&quot;, color=&quot;b&quot;)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">din</span><span class="p">,</span><span class="n">vout_nonlinear</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Non-Linear DAC&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">din</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vref</span> <span class="o">+</span> <span class="n">vlsb</span><span class="p">,</span> <span class="n">vlsb</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Input code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output voltage [V]&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;DAC Transfer Function&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_3_files/practical_class_3_9_0.png" /></p>
<p align="justify">
As it is possible to observe, the exagerated transfer function non-linearities represented in the plot above feature variable output voltages for the non-ideal DAC, due to the quantization noise. The noise was multiplied by an amplification factor to better observe the effect of the quantization noise in the non-linear behaviour of the DAC's transfer function.
</p>

<p align="justify">
The non-linear errors of converters can come in two forms:
<ul>
<li>Differential Non-Linearity (DNL), given in Eq.(5),</li>
<li>Integral Non-Linearity (INL), given in Eq.(6).</li>
</ul>

The DNL and INL are measured in LSB units. The DNL provides a method of locally observing how much each step size changes in each transition. The INL on the other hand is the accumulation of the DNL up until the respective transition, and enables the measurement of the global step-size variability throughout every transition of the transfer function. In DACs, the INL and DNL, as well as any other kind of error, are measured in the vertical axis, where the voltage unit is. Eq. (4) presents the actual measured least significant bit step voltage of the DAC.
</p>

<p>$$ V_{LSB}' = \frac{V_{OUT}'[2^N - 1] - V_{OUT}'[0]}{2^N - 1} \hspace{4 pt} [V] \hspace{10 pt} (4)$$</p>
<p>$$ DNL[n] = \frac{V_{OUT}'[n+1] - V_{OUT}'[n]}{V_{LSB}'} \hspace{4 pt} [LSB], n\in [0, 2^N-2] \hspace{10 pt} (5) $$</p>
<p>$$ INL[n] = \frac{V_{OUT}'[n] - n\times V_{LSB}' - V_{OUT}'[0]}{V_{LSB}'} \hspace{4 pt} [LSB], n\in [0, 2^N-1] \hspace{10 pt} (6) $$</p>
<p>where $V_{OUT}'[n]$ is the output voltage of the real DAC at the $n^{th}$ transition and $V_{LSB}'$ is the measured step size of the non-ideal DAC.</p>
<p align="justify">
<b>NOTE:</b> The INL and DNL can only be calculated after removing the linear error sources (offset, and gain errors).
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># measure the real vlsb</span>
<span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonlinear</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_nonlinear</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The ideal vlsb is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2"> V&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vlsb</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The measured vlsb is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2"> V&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vlsb_measured</span><span class="p">))</span>
<span class="c1"># measure the DNL of the DAC</span>
<span class="n">dnl</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonlinear</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span> <span class="o">-</span> <span class="n">vout_nonlinear</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">dnl_pythonic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout_nonlinear</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dnl</span><span class="p">,</span> <span class="n">dnl_pythonic</span><span class="p">),</span> <span class="s2">&quot;The DNL two methods give different results&quot;</span>
<span class="c1"># assert that n is in [0, 2**n_bits-2] for the DNL</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;The DNL has a wrong length&quot;</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span>
<span class="n">inl</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonlinear</span> <span class="o">-</span> <span class="n">idx</span><span class="o">*</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="n">vout_nonlinear</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb_measured</span>
<span class="c1"># assert that n is in [0, 2**n_bits-1] for the INL</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">,</span> <span class="s2">&quot;The INL has a wrong length&quot;</span>
<span class="c1"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">din</span><span class="p">[</span><span class="mi">1</span><span class="p">::],</span> <span class="n">dnl</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DNL&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">din</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;INL&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Input code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Input code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;DNL&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;INL&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;DAC Non-Linearity&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>The ideal vlsb is 0.0625 V
The measured vlsb is 0.0632 V





&lt;matplotlib.legend.Legend at 0x134f82090&gt;
</code></pre></div>

<p><img alt="png" src="practical_class_3_files/practical_class_3_11_2.png" /></p>
<h2 id="adc-error-modelling">ADC Error Modelling</h2>
<h3 id="adc-linear-errors">ADC Linear Errors</h3>
<p align="justify"> 
This section presents the modelling of the linear errors that arise when modelling the transfer function of a ADC. These errors relate to a deviation of the real transfer function of the ADC towards the ideal ADC's transfer function, in which each step size is exactly the same width!
It is important to note that in this case (ADC), it is the transition voltlallges of the ADC that deviate from ideal ones, without ever changing step size!
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the ADC </span>
<span class="n">vref</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define the reference voltage [V]</span>
<span class="n">n_bits</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># define the number of bits of the DAC</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span> <span class="c1"># compute the fundamental step voltage between quantized levels</span>
<span class="c1"># define an ideal DAC to compare the results</span>
<span class="n">roundf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span>
<span class="n">iadc</span> <span class="o">=</span> <span class="n">ideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">roundf</span><span class="p">)</span>
<span class="c1"># define the non-ideal ADC with linear errors</span>
<span class="c1"># to procees with this step, we need to define </span>
<span class="c1"># an ADC modelling function that is closer to the </span>
<span class="c1"># its physical implementation - the model should include</span>
<span class="c1"># the transition voltages as a characteristic parameter</span>
<span class="c1"># and the input voltage will only provoke a transition</span>
<span class="c1"># if the input voltage is greater than the corresponding</span>
<span class="c1"># transition voltage</span>
<span class="c1"># define an ADC with offset error</span>
<span class="n">voff</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">adc_off</span><span class="p">,</span> <span class="n">vt_off</span> <span class="o">=</span> <span class="n">nonideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">roundf</span><span class="o">=</span><span class="n">roundf</span><span class="p">,</span> <span class="n">ofst</span><span class="o">=</span><span class="n">voff</span><span class="p">)</span>
<span class="c1"># define a ADC with end of scale error</span>
<span class="c1"># note that the end of scale error </span>
<span class="c1"># is actually directly related to</span>
<span class="c1"># the gain error of the ADC</span>

<span class="c1"># The gain error of the ADC is directly related to the</span>
<span class="c1"># VREF voltage variation of the ADC. The lower the VREF</span>
<span class="c1"># the lower will be vlsb, and as such, the higher will be </span>
<span class="c1"># the end of scale error once the gain decreases. The </span>
<span class="c1"># reciprocal is also true, the higher the VREF the higher</span>
<span class="c1"># will be the Vlsb, and as such, the higher will be the</span>
<span class="c1"># the gain of the ADC.</span>
<span class="n">vref_err</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.05</span> <span class="c1"># -5% Vref variation</span>
<span class="n">true_vref</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">vref_err</span><span class="p">)</span><span class="o">*</span><span class="n">vref</span>
<span class="n">adc_eos</span><span class="p">,</span> <span class="n">vt_eos</span> <span class="o">=</span> <span class="n">nonideal_adc</span><span class="p">(</span>
    <span class="n">true_vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">roundf</span><span class="o">=</span><span class="n">roundf</span><span class="p">)</span>
<span class="c1"># define a DAC with offset and end of scale error</span>
<span class="c1"># to measure the true DAC gain error</span>
<span class="n">adc_off_eos</span><span class="p">,</span> <span class="n">vt_off_eos</span> <span class="o">=</span> <span class="n">nonideal_adc</span><span class="p">(</span>
    <span class="n">true_vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">roundf</span><span class="o">=</span><span class="n">roundf</span><span class="p">,</span> <span class="n">ofst</span><span class="o">=</span><span class="n">voff</span><span class="p">)</span>
<span class="c1"># define the input voltages of the ADC</span>
<span class="n">vin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">vlsb</span><span class="p">)</span>
<span class="n">vt_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">vt_off</span><span class="p">))</span>
<span class="n">vt_eos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">vt_eos</span><span class="p">))</span>
<span class="n">vt_off_eos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">vt_off_eos</span><span class="p">))</span>
<span class="c1"># create the string representation of the input codes</span>
<span class="c1"># compute the output voltages of the 3 DACs</span>
<span class="n">dout</span> <span class="o">=</span> <span class="n">iadc</span><span class="p">(</span><span class="n">vin</span><span class="p">)</span>
<span class="n">dout_off</span> <span class="o">=</span> <span class="n">adc_off</span><span class="p">(</span><span class="n">vin</span><span class="p">)</span>
<span class="n">dout_eos</span> <span class="o">=</span> <span class="n">adc_eos</span><span class="p">(</span><span class="n">vin</span><span class="p">)</span>
<span class="n">dout_off_eos</span> <span class="o">=</span> <span class="n">adc_off_eos</span><span class="p">(</span><span class="n">vin</span><span class="p">)</span>
<span class="c1"># convert the output codes to decimals</span>
<span class="n">dout_dec</span> <span class="o">=</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="n">dout_off_dec</span> <span class="o">=</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">dout_off</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="n">dout_eos_dec</span> <span class="o">=</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">dout_eos</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="n">dout_off_eos_dec</span> <span class="o">=</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">dout_off_eos</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vin</span><span class="p">,</span> <span class="n">dout_dec</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ideal ADC&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">vt_off</span><span class="p">,</span> <span class="n">dout_off_dec</span><span class="p">,</span><span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADC with offset error&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">vt_eos</span><span class="p">,</span> <span class="n">dout_eos_dec</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADC with end of scale error&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">vt_off_eos</span><span class="p">,</span> <span class="n">dout_off_eos_dec</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ADC with offset and end of scale error&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Input voltage [V]&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;ADC Transfer Function&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_3_files/practical_class_3_14_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute linear error ratios</span>
<span class="n">e_off</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb</span>
<span class="n">e_eos</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_off_eos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb</span>
<span class="n">ger_pct</span> <span class="o">=</span> <span class="p">((</span><span class="n">vout_off_eos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_off_eos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">vin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The offset error is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> LSB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e_off</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The end of scale error is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> LSB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e_eos</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The gain error is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2"> %&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ger_pct</span><span class="p">))</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nv">The</span><span class="w"> </span><span class="nv">offset</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="mi">0</span>.<span class="mi">80</span><span class="w"> </span><span class="nv">LSB</span><span class="w"></span>
<span class="nv">The</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">scale</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="o">-</span><span class="mi">0</span>.<span class="mi">25</span><span class="w"> </span><span class="nv">LSB</span><span class="w"></span>
<span class="nv">The</span><span class="w"> </span><span class="nv">gain</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="o">-</span><span class="mi">7</span>.<span class="mi">00</span><span class="w"> </span><span class="o">%</span><span class="w"></span>
</code></pre></div>

<h3 id="adc-non-linear-errors">ADC Non-Linear Errors</h3>
<p align="justify"> 
This section presents the modelling of the non-linear errors that arise when modelling the transfer function of a ADC. These errors relate to a deviation of the real transfer function of the ADC towards the ideal ADC's transfer function, in which each step size can differ in width due to the inherent non-linearity that arises when quantizing a noisy signal! In a physical implementation, the intrinsic non-linearities that devices present are usually the main source of non-linear errors in ADCs, directly affecting the position of the transition voltages of the ADC.
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the ADC </span>
<span class="n">vref</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define the reference voltage [V]</span>
<span class="n">n_bits</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># define the number of bits of the DAC</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span><span class="p">)</span> <span class="c1"># compute the fundamental step voltage between quantized levels</span>
<span class="n">roundf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span>
<span class="c1"># define an ideal DAC to compare the results</span>
<span class="n">iadc</span> <span class="o">=</span> <span class="n">ideal_adc</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">roundf</span><span class="p">)</span>
<span class="c1"># define the noise signal with a uniform distribution</span>
<span class="n">vq_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">vlsb</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span>
<span class="n">vq_std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vq_var</span><span class="p">)</span>
<span class="n">noise_factor</span><span class="o">=</span><span class="mi">2</span>
<span class="n">adc_nonlinear</span><span class="p">,</span> <span class="n">vtrans</span> <span class="o">=</span> <span class="n">nonideal_adc</span><span class="p">(</span>
    <span class="n">vref</span><span class="p">,</span> <span class="n">n_bits</span><span class="p">,</span> <span class="n">roundf</span><span class="o">=</span><span class="n">roundf</span><span class="p">,</span>
    <span class="n">vnq</span><span class="o">=</span><span class="n">noise_factor</span><span class="o">*</span><span class="n">vq_std_dev</span><span class="p">)</span>
<span class="c1"># define the input voltages of the ADC</span>
<span class="n">vin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">vlsb</span><span class="p">)</span>
<span class="c1"># compute the output codes of the ADC</span>
<span class="n">dout</span> <span class="o">=</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">iadc</span><span class="p">(</span><span class="n">vin</span><span class="p">),</span> <span class="n">n_bits</span><span class="p">)</span>
<span class="n">dout_nonlinear</span> <span class="o">=</span> <span class="n">bin2dec</span><span class="p">(</span><span class="n">adc_nonlinear</span><span class="p">(</span><span class="n">vin</span><span class="p">),</span> <span class="n">n_bits</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vin</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ideal ADC&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">vin</span><span class="p">,</span> <span class="n">dout_nonlinear</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;non-linear ADC&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Input voltage [V]&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;ADC Transfer Function&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_3_files/practical_class_3_18_0.png" /></p>
<p align="justify">
From both figures observed in this ADC section (2.1 and 2.2),
a very important conclusion can be taken: both linear and non-linear errors can lead to missing codes in the output of the ADC, which eventually leads to a loss of effective resolution of the converter.
</p>

<p align="justify">
Analogously to the DAC section, the non-linear errors of converters can come in two forms:
<ul>
<li>Differential Non-Linearity (DNL), given in Eq.(8),</li>
<li>Integral Non-Linearity (INL), given in Eq.(9).</li>
</ul>

The DNL and INL are measured in LSB units. The DNL provides a method of locally observing how much each step size changes in each transition voltage. The INL on the other hand is the accumulation of the DNL up until the respective transition, and enables the measurement of the global transition voltage step-size variability throughout every transition of the transfer function. In ADCs, the INL and DNL, as well as any other kind of error, are measured in the horizontal axis, where the voltage unit is. Eq. (7) presents the actual measured least significant bit step voltage of the ADC.
</p>

<p>$$ V_{LSB}' = \frac{V_{T}'[2^N - 1] - V_{T}'[1]}{2^N - 2} \hspace{4 pt} [V] \hspace{10 pt} (7) $$</p>
<p>$$ DNL[n] = \frac{V_{T}'[n+1] - V_{T}'[n]}{V_{LSB}'} \hspace{4 pt} [LSB], n\in [0, 2^N-3] \hspace{10 pt} (8) $$</p>
<p>$$ INL[n] = \frac{V_{T}'[n] - n\times V_{LSB}' - V_{T}'[1]}{V_{LSB}'} \hspace{4 pt} [LSB], n\in [0, 2^N-2] \hspace{10 pt} (9) $$</p>
<p>where $V_{T}'[n]$ is the transition voltage level of the real ADC at the $n^{th}$ transition and $V_{LSB}'$ is the measured least significant bit step size of the non-ideal ADC.</p>
<p>In this case (ADC), there are $2^N$ intervals, but only $2^N - 1$ transition voltages, whereas in the DAC case there are $2^N$ intervals and $2^N$ output voltages</p>
<p align="justify">
<b>NOTE:</b> The INL and DNL can only be calculated after removing the linear error sources (offset, and gain errors).
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># compute the non linearity of the ADC</span>
<span class="c1"># compute the measured vlsb</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vtrans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vtrans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vtrans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vtrans</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The ideal vlsb is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2"> V&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vlsb</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The measured vlsb is &quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2"> V&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vlsb_measured</span><span class="p">))</span>
<span class="c1"># compute the DNL</span>
<span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vtrans</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
<span class="c1"># assert that n is in [0, 2**n_bits-3] for the DNL</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;The number of DNL values is not correct&quot;</span>
<span class="c1"># compute the INL</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vtrans</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">inl</span> <span class="o">=</span> <span class="p">(</span><span class="n">vtrans</span> <span class="o">-</span> <span class="n">idx</span><span class="o">*</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="n">vtrans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">vlsb_measured</span>
<span class="c1"># assert that n is in [0, 2**n_bits-2] for the INL</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;The number of INL values is not correct&quot;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>The ideal vlsb is 0.0312 V
The measured vlsb is 0.0319 V
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vtrans</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># define the DNL transition codes</span>
<span class="c1"># plot the results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">dnl</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;DNL&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;INL&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;DNL&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;INL&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;DNL and INL&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="practical_class_3_files/practical_class_3_21_0.png" /></p>
<h1 id="noise-modelling">Noise modelling</h1>
<p align="justify">
Noise is a very important factor in the design of a system. It is important to know how much noise is generated by a system and how much noise is introduced into the system by the surrounding environment/systems. This practical class covers how to model noise in a converter, and what are the impacts of the several sources of noise in the overall performance.
</p>

<p align="justify">
There are three primary noise sources in a converter:
<ul>
    <li>Quantization Noise (Quantization Error Noise model aproximated by a uniform distribution)</li>
    <li>Gaussian Noise (Innevitable source of noise, in the form of thermal, quantic and other electromagnetic phenomena happening in the circuit blocks)
    <ul>
        <li>Thermal Noise</li>
        <li>Shot Noise</li>
    </ul>
    </li>
    <li>Jitter Noise (Phase Noise generated by the random switching time stamps of the switches in the converter)</li>
</ul>
</p>

<p align="justify">
The complete model of a Analog-to-Analog converter signal chain is presented in the figure below, including the noise sources and the noise propagation through the system.

<p align="center">
<img src="./imgs/total_output_noise.png" width="400">
</p>

</p>

<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">k</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">normal</span> <span class="c1"># import uniform and normal probability distributions to represent noise</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">import</span> <span class="nn">scienceplots</span>
<span class="c1">#sns.set_theme()</span>
<span class="c1">#sns.set_palette(&#39;colorblind&#39;)</span>

<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">bin2dec</span><span class="p">,</span> <span class="n">dec2bin</span><span class="p">,</span> <span class="n">ideal_dac</span><span class="p">,</span> <span class="n">ideal_adc</span><span class="p">,</span> <span class="n">nonideal_adc</span>

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">([</span><span class="s1">&#39;science&#39;</span><span class="p">,</span> <span class="s1">&#39;notebook&#39;</span><span class="p">])</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the number of simulation points</span>
<span class="n">Np</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="c1"># define the frequency of the sampling clock</span>
<span class="n">Fclk</span> <span class="o">=</span> <span class="mf">100e3</span> <span class="c1"># Hz</span>
<span class="c1"># define the time base</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fclk</span>
<span class="n">tD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Np</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</code></pre></div>

<h2 id="jitter-noise-modelling">Jitter Noise Modelling</h2>
<p align="justify">
As stated before, jitter noise can be thought of a representation of the time uncertainty at which the sampling switches sampled an analog signal. The uncertainty at which the time the sampled was taken will introduce an error on the value of the sampled signal, at the corresponding sampling instant. 
</p>

<p align="center">
<img src="./imgs/jitter_noise.png" width=400>
</p>

<p>The sampled signal error can be represented by:
$$ s[n] = s(n<em>T_S + \Delta t_j) = s(n</em>T_S) + \epsilon_s$$</p>
<p>Considering a sinusoidal signal s(t) given by:</p>
<p>$$ s(t) = A \hspace{2 pt} sin(2\pi f_S t + \phi) $$</p>
<p align="justify">
then using a first order taylor series aproximation of the sampled sinusoidal signal, we can obtain the contribution of the jitter noise to the error of the sampled signal:
</p>

<p>$$ s[n] = A \hspace{2 pt} sin(2\pi f_S (nT_S + \Delta t_j)) \approx A \hspace{2 pt} sin(2\pi f_S (nT_S)) + A 2\pi f_S \Delta t_j \hspace{2 pt} cos(2\pi f_S (nT_S) ) $$</p>
<p align="juustify">
The power of the reuslting signal can be separated into two main components, the power of the signal and the power of the jitter noise:
</p>

<p>$$ P = P_s + P_j = \frac{A^2}{2} + \frac{A^2}{2}f_S^24\pi^2\sigma_t^2 $$</p>
<p>where $\sigma_t$ is the standard deviation of the random variable with normal distribution modelling the time uncertainty error $\Delta t_j$ - referred to as jitter -, $f_S$ is the sampling frequency and $A$ is the amplitude of the analog signal being sampled.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># let us create an ideal adc featuring jitter noise</span>
<span class="c1"># define the adc</span>
<span class="n">nbit</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbit</span><span class="p">)</span>
<span class="c1"># define the input signal</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># V</span>
<span class="n">f1</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># Hz</span>
<span class="c1"># setup the input signal frequency to behold </span>
<span class="c1"># coherent sampling</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">f1</span><span class="o">/</span><span class="n">Fclk</span><span class="o">*</span> <span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Fclk</span><span class="o">/</span><span class="n">Np</span> <span class="c1"># Hz</span>
<span class="n">ph1</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># rad</span>

<span class="n">mV</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="c1"># V</span>
<span class="n">dc_level</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>

<span class="c1"># setup the jitter noise</span>
<span class="n">sig_t</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="c1"># sigma_t</span>
<span class="n">jitter_stdev</span> <span class="o">=</span> <span class="n">A1</span><span class="o">*</span><span class="n">Fclk</span><span class="o">*</span><span class="n">sig_t</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="c1"># jitter amplitude = jitter standard deviation</span>
<span class="n">jitter_noise</span> <span class="o">=</span> <span class="n">jitter_stdev</span><span class="o">*</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jitter_stdev</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span>
<span class="n">si</span> <span class="o">=</span> <span class="n">A1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f1</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">ph1</span><span class="p">)</span> <span class="o">+</span> <span class="n">dc_level</span> <span class="o">+</span> <span class="n">jitter_noise</span>
<span class="c1"># define the dout </span>
<span class="n">dout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">si</span> <span class="o">/</span> <span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># observe the jitter noise probability density function</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v_scale</span> <span class="o">=</span> <span class="n">mV</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">jitter_noise</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">x_ticks</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticks</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="o">/</span><span class="n">v_scale</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_ticks</span><span class="p">[::</span><span class="n">freq</span><span class="p">]])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Probability&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Normal Distribution - Jitter Noise&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Jitter Noise - Std. Dev (mV)&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">folders</span><span class="o">/</span><span class="n">vv</span><span class="o">/</span><span class="n">xctyh4bd2td6k2w_gvh_t2vr0000gn</span><span class="o">/</span><span class="n">T</span><span class="o">/</span><span class="n">ipykernel_55844</span><span class="o">/</span><span class="mf">3403075116.</span><span class="n">py</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="w"> </span><span class="n">UserWarning</span><span class="p">:</span><span class="w"> </span><span class="n">set_ticklabels</span><span class="p">()</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">ticks</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">set_ticks</span><span class="p">()</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">FixedLocator</span><span class="o">.</span><span class="w"></span>
<span class="w">  </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="n">f</span><span class="s2">&quot;{val/v_scale:.1f}&quot;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">x_ticks</span><span class="p">[::</span><span class="n">freq</span><span class="p">]])</span><span class="w"></span>





<span class="n">Text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Jitter Noise - Std. Dev (mV)&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_8_2.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="n">t_scale</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="c1"># ms</span>
<span class="c1"># observe dout and s3</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="o">/</span><span class="n">t_scale</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Input Signal (V)&quot;</span><span class="p">)</span>    
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="o">/</span><span class="n">t_scale</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (ms)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output Code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Input signal and output code&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">Text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Input signal and output code&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_9_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the snr of the adc</span>
<span class="n">f_scale</span> <span class="o">=</span> <span class="mf">1e3</span>
<span class="n">p_scale</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">virt_zero</span> <span class="o">=</span> <span class="mf">1e-30</span>

<span class="n">fD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="c1"># compute the fft of the dout signal </span>
<span class="n">dout_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">dout</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>
<span class="n">dout_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">dout_f</span><span class="o">*</span><span class="n">dout_f</span><span class="p">)</span>
<span class="n">dout_p</span><span class="p">[</span><span class="n">dout_p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_zero</span>
<span class="n">dout_db</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dout_p</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># observe the spectrum</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">f_scale</span><span class="p">,</span> <span class="n">dout_db</span><span class="p">[</span><span class="n">fD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">p_scale</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span>   
<span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Dout (dB)&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dout Frequency Spectrum - Jitter Noise Superposition&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;Dout Frequency Spectrum - Jitter Noise Superposition&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_11_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the snr of the adc</span>
<span class="c1"># snr computation </span>
<span class="n">bins</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">fDp</span> <span class="o">=</span> <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dout_p_fp</span> <span class="o">=</span> <span class="n">dout_p</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fin_bin</span> <span class="o">=</span> <span class="n">fDp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f1</span> <span class="o">-</span> <span class="n">fDp</span><span class="p">))]</span>

<span class="n">p_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dout_p_fp</span><span class="p">[</span><span class="n">fDp</span> <span class="o">==</span> <span class="n">fin_bin</span><span class="p">][:</span><span class="n">bins</span><span class="p">])</span> <span class="c1"># power of the signal</span>

<span class="c1"># get an ideal spectrum</span>
<span class="n">ideal_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dout_p_fp</span><span class="p">))</span>
<span class="n">ideal_spectrum</span><span class="p">[</span><span class="n">fDp</span> <span class="o">==</span> <span class="n">fin_bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_in</span>

<span class="c1"># compute the noise spectrum, ignoring the dc component</span>
<span class="n">noise_spectrum</span> <span class="o">=</span> <span class="n">dout_p_fp</span> <span class="o">-</span> <span class="n">ideal_spectrum</span>
<span class="c1"># compute the noise power of the spectrum</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise_spectrum</span><span class="p">[</span><span class="n">bins</span><span class="p">:])</span>
<span class="n">snr</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p_in</span><span class="o">/</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Obtained SNR= </span><span class="si">{</span><span class="n">snr</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Obtained SNR= 77.74 dB
</code></pre></div>

<h2 id="gaussian-noise-sources-thermal-noise">Gaussian Noise Sources - Thermal Noise</h2>
<p align="justify">
The circuit blocks that constitute a converter usually include a resistors, capacitors, an amplifier, a comparator, a latch or any other form of CMOS-based circuit block, to perform bit conversions. As passive devices and transistors operate in normal conditions, they dissipate power in the form of heat, while transistors are also subjected to random quantum tunneling effects regarding the gate-accumulated electric charges that break the dielectric, passing from and to the transistor channel. The need arises then to model these effects into palpable random variables that superpose the input/output signal of A/D and D/A converters. Because thermal noise is the strongest of the described noise sources and is present in all converter architectures that are going to be described, only thermal noise will be modelled in this section.
</p>

<p align="justify">
The thermal noise associated with a given component is directly proportional to its impedance. The higher the impedance, the higher will be the thermal noise superposed to the processed signal.
</p>

<p><b align="left">Power spectral density of Resistor-associated Thermal Noise (votlage variance per hertz/bandwidth):</b>
$$ \langle v^2_{T} \rangle = 4 k_B T_{(K)} R \hspace{4 pt} [V^2/Hz]$$ </p>
<p><b align="left">Power spectral density of a Capacitor-associated Thermal Noise (votlage variance per hertz/bandwidth):</b></p>
<p>$$ \langle v^2_{T} \rangle = \frac{ k_B T_{(K)} }{ C } \hspace{4 pt} [V^2/Hz]$$ </p>
<p><b align="left">Power spectral density of a CMOS Transistor channel-associated Thermal Noise (seen at the gate) (votlage variance per hertz/bandwidth):</b></p>
<p>$$ \langle v^2_{T} \rangle = \frac{ \gamma k_B T_{(K)} }{ g_m } \hspace{4 pt} [V^2/Hz]$$ </p>
<p>where $ \gamma $ is a technology parameter associated with quantum tunneling effects.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># consider an ideal adc converting an input signal superposed by thermal noise</span>

<span class="c1"># let us create an ideal adc featuring jitter noise</span>
<span class="c1"># define the adc</span>
<span class="n">nbit</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbit</span><span class="p">)</span>
<span class="c1"># define the input signal</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># V</span>
<span class="n">f2</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># Hz</span>
<span class="c1"># setup the input signal frequency to behold </span>
<span class="c1"># coherent sampling</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">f2</span><span class="o">/</span><span class="n">Fclk</span><span class="o">*</span> <span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Fclk</span><span class="o">/</span><span class="n">Np</span> <span class="c1"># Hz</span>
<span class="c1"># signal bandwidth</span>
<span class="n">BW</span> <span class="o">=</span> <span class="n">f2</span><span class="o">*</span><span class="mi">2</span>
<span class="n">ph2</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># rad</span>

<span class="n">mV</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="c1"># V</span>
<span class="n">dc_level</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>

<span class="c1"># setup the thermal noise</span>
<span class="c1"># consider the input signal passing through a sample and hold </span>
<span class="c1"># switch - capacitor circuit, considering a switch </span>
<span class="c1"># with an on resistance of 1kOhm and a capacitor with </span>
<span class="c1"># 100 fF</span>
<span class="c1"># resistance</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">1e3</span> 
<span class="c1"># capacitance</span>
<span class="n">C</span> <span class="o">=</span> <span class="mf">0.1e-12</span> <span class="c1"># 0.1 pF</span>
<span class="c1"># temperature celsius</span>
<span class="n">T_cels</span> <span class="o">=</span> <span class="mi">85</span> <span class="c1"># in a circuit operating at 85 degrees celsius</span>
<span class="c1"># temperature kelvin</span>
<span class="n">T_kelv</span> <span class="o">=</span> <span class="n">T_cels</span> <span class="o">+</span> <span class="mf">273.15</span>
<span class="c1"># noise voltage variance</span>
<span class="n">vn_t_var</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">T_kelv</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">BW</span> <span class="o">+</span> <span class="n">BW</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">T_kelv</span><span class="o">/</span><span class="n">C</span>
<span class="n">vn_t_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vn_t_var</span><span class="p">)</span>
<span class="n">thermal_noise</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vn_t_std</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span>
<span class="n">si</span> <span class="o">=</span> <span class="n">A2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f2</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">ph2</span><span class="p">)</span> <span class="o">+</span> <span class="n">dc_level</span> <span class="o">+</span> <span class="n">thermal_noise</span>
<span class="c1"># define the dout </span>
<span class="n">dout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">si</span> <span class="o">/</span> <span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># observe the thermal noise probability density function</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v_scale</span> <span class="o">=</span> <span class="n">mV</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">thermal_noise</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">x_ticks</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticks</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="o">/</span><span class="n">v_scale</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_ticks</span><span class="p">[::</span><span class="n">freq</span><span class="p">]])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Probability&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Normal Distribution - Thermal Noise&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Thermal Noise - Std. Dev (mV)&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">folders</span><span class="o">/</span><span class="n">vv</span><span class="o">/</span><span class="n">xctyh4bd2td6k2w_gvh_t2vr0000gn</span><span class="o">/</span><span class="n">T</span><span class="o">/</span><span class="n">ipykernel_55844</span><span class="o">/</span><span class="mf">1511684446.</span><span class="n">py</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="w"> </span><span class="n">UserWarning</span><span class="p">:</span><span class="w"> </span><span class="n">set_ticklabels</span><span class="p">()</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">ticks</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">set_ticks</span><span class="p">()</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">FixedLocator</span><span class="o">.</span><span class="w"></span>
<span class="w">  </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="n">f</span><span class="s2">&quot;{val/v_scale:.1f}&quot;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">x_ticks</span><span class="p">[::</span><span class="n">freq</span><span class="p">]])</span><span class="w"></span>





<span class="n">Text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Thermal Noise - Std. Dev (mV)&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_17_2.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="n">t_scale</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="c1"># ms</span>
<span class="c1"># observe dout and s3</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="o">/</span><span class="n">t_scale</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Input Signal (V)&quot;</span><span class="p">)</span>    
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="o">/</span><span class="n">t_scale</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (ms)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output Code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Input signal and output code&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">Text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Input signal and output code&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_18_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the snr of the adc</span>
<span class="n">f_scale</span> <span class="o">=</span> <span class="mf">1e3</span>
<span class="n">p_scale</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">virt_zero</span> <span class="o">=</span> <span class="mf">1e-30</span>

<span class="n">fD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="c1"># compute the fft of the dout signal </span>
<span class="n">dout_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">dout</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>
<span class="n">dout_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">dout_f</span><span class="o">*</span><span class="n">dout_f</span><span class="p">)</span>
<span class="n">dout_p</span><span class="p">[</span><span class="n">dout_p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_zero</span>
<span class="n">dout_db</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dout_p</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># observe the spectrum</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">f_scale</span><span class="p">,</span> <span class="n">dout_db</span><span class="p">[</span><span class="n">fD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">p_scale</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span>   
<span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Dout (dB)&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dout Frequency Spectrum - Thermal Noise Superposition&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;Dout Frequency Spectrum - Thermal Noise Superposition&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_20_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the snr of the adc</span>
<span class="c1"># snr computation </span>
<span class="n">bins</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">fDp</span> <span class="o">=</span> <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dout_p_fp</span> <span class="o">=</span> <span class="n">dout_p</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fin_bin</span> <span class="o">=</span> <span class="n">fDp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f2</span> <span class="o">-</span> <span class="n">fDp</span><span class="p">))]</span>
<span class="n">p_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dout_p_fp</span><span class="p">[</span><span class="n">fDp</span> <span class="o">==</span> <span class="n">fin_bin</span><span class="p">][:</span><span class="n">bins</span><span class="p">])</span> <span class="c1"># power of the signal</span>

<span class="c1"># get an ideal spectrum</span>
<span class="n">ideal_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dout_p_fp</span><span class="p">))</span>
<span class="n">ideal_spectrum</span><span class="p">[</span><span class="n">fDp</span> <span class="o">==</span> <span class="n">fin_bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_in</span>

<span class="c1"># compute the noise spectrum, ignoring the dc component</span>
<span class="n">noise_spectrum</span> <span class="o">=</span> <span class="n">dout_p_fp</span> <span class="o">-</span> <span class="n">ideal_spectrum</span>
<span class="c1"># compute the noise power of the spectrum</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise_spectrum</span><span class="p">[</span><span class="n">bins</span><span class="p">:])</span>
<span class="n">snr</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p_in</span><span class="o">/</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Obtained SNR= </span><span class="si">{</span><span class="n">snr</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Obtained SNR= 57.63 dB
</code></pre></div>

<h2 id="quantization-noise-modelling">Quantization Noise Modelling</h2>
<p align="justify">
Each conversion of a signal converter system is prone to <b>quantization error</b>, once the converter parses the signal between the digital and analog domain using a discrete quantization step (Vlsb). As such, each converter signal sample can present an error between [-Vlsb/2 ; Vlsb/2]. Because all systems are subjected to noise, the signal is always superposed by random gaussian noise, and this noise is also converted with the signal in the process of parsing from digital to analog domains. If the superposed noise of the signal doesn't surpass the threshold of |Vlsb/2| level, than the sufficiently random nature of the converted analog signal enables <b>quantization error</b> to be well approximated by white noise - a random noise variable with a uniform distribution of probability - becoming <b>Quantization Noise</b>.
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># define the adc</span>
<span class="n">nbit</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">1</span> 
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbit</span><span class="p">)</span>
<span class="c1"># define the input signal</span>
<span class="n">A3</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># V</span>
<span class="n">f3</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># Hz</span>
<span class="c1"># setup the input signal frequency to behold </span>
<span class="c1"># coherent sampling</span>
<span class="n">f3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">f3</span><span class="o">/</span><span class="n">Fclk</span><span class="o">*</span> <span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Fclk</span><span class="o">/</span><span class="n">Np</span> <span class="c1"># Hz</span>
<span class="n">ph3</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># rad</span>
<span class="n">mV</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="c1"># V</span>
<span class="n">dc_level</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">A3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f3</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">ph3</span><span class="p">)</span> <span class="o">+</span> <span class="n">dc_level</span>
<span class="c1"># compute the quantization error</span>
<span class="n">p_nq</span> <span class="o">=</span> <span class="n">vlsb</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">12</span> <span class="c1"># V**2</span>
<span class="n">vnq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p_nq</span><span class="p">)</span> <span class="c1"># V</span>
<span class="c1"># define the input signal with quantization error</span>
<span class="n">vnq_t</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">vnq</span><span class="p">,</span> <span class="n">vnq</span><span class="p">,</span> <span class="n">Np</span><span class="p">)</span> <span class="c1"># V</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">s3</span> <span class="o">+</span> <span class="n">vnq_t</span>
<span class="c1"># define the dout </span>
<span class="n">dout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">s3</span> <span class="o">/</span> <span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># observe the quantization noise probability density function</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">freq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v_scale</span> <span class="o">=</span> <span class="n">mV</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">vnq_t</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">x_ticks</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xticks</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="o">/</span><span class="n">v_scale</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x_ticks</span><span class="p">[::</span><span class="n">freq</span><span class="p">]])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Probability&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Uniform Distribution - Quantization Noise&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Quantization Noise - Std. Dev (mV)&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">folders</span><span class="o">/</span><span class="n">vv</span><span class="o">/</span><span class="n">xctyh4bd2td6k2w_gvh_t2vr0000gn</span><span class="o">/</span><span class="n">T</span><span class="o">/</span><span class="n">ipykernel_55844</span><span class="o">/</span><span class="mf">4039833531.</span><span class="n">py</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="w"> </span><span class="n">UserWarning</span><span class="p">:</span><span class="w"> </span><span class="n">set_ticklabels</span><span class="p">()</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">ticks</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">set_ticks</span><span class="p">()</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">FixedLocator</span><span class="o">.</span><span class="w"></span>
<span class="w">  </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="n">f</span><span class="s2">&quot;{val/v_scale:.1f}&quot;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">x_ticks</span><span class="p">[::</span><span class="n">freq</span><span class="p">]])</span><span class="w"></span>





<span class="n">Text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Quantization Noise - Std. Dev (mV)&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_24_2.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># observe dout and s3</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Input Signal (V)&quot;</span><span class="p">)</span>    
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">dout</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Output Code&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Input signal and output code&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">Text</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Input signal and output code&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_25_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="n">f_scale</span> <span class="o">=</span> <span class="mf">1e3</span>
<span class="n">p_scale</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Np</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>

<span class="n">new_zero</span> <span class="o">=</span> <span class="mf">1e-30</span>

<span class="c1"># compute the fft of the dout signal </span>
<span class="n">dout_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">dout</span><span class="p">)</span> <span class="o">/</span> <span class="n">Np</span><span class="p">))</span>
<span class="n">dout_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">dout_f</span><span class="o">*</span><span class="n">dout_f</span><span class="p">)</span>
<span class="n">dout_p</span><span class="p">[</span><span class="n">dout_p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_zero</span> <span class="c1"># trick to prevent log10 from raising exceptions</span>
<span class="n">dout_db</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dout_p</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># compute the snr of the adc</span>
<span class="c1"># snr computation </span>
<span class="n">bins</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">fDp</span> <span class="o">=</span> <span class="n">fD</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dout_p_fp</span> <span class="o">=</span> <span class="n">dout_p</span><span class="p">[</span><span class="n">fD</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fin_bin</span> <span class="o">=</span> <span class="n">fDp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f3</span> <span class="o">-</span> <span class="n">fDp</span><span class="p">))]</span>

<span class="n">p_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dout_p_fp</span><span class="p">[</span><span class="n">fDp</span> <span class="o">==</span> <span class="n">fin_bin</span><span class="p">][:</span><span class="n">bins</span><span class="p">])</span> <span class="c1"># power of the signal</span>

<span class="c1"># get an ideal spectrum</span>
<span class="n">ideal_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dout_p_fp</span><span class="p">))</span>
<span class="n">ideal_spectrum</span><span class="p">[</span><span class="n">fDp</span> <span class="o">==</span> <span class="n">fin_bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_in</span>

<span class="c1"># compute the noise spectrum, ignoring the dc component</span>
<span class="n">noise_spectrum</span> <span class="o">=</span> <span class="n">dout_p_fp</span> <span class="o">-</span> <span class="n">ideal_spectrum</span>
<span class="c1"># compute the noise power of the spectrum</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise_spectrum</span><span class="p">[</span><span class="n">bins</span><span class="p">:])</span>
<span class="n">snr</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p_in</span><span class="o">/</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Obtained SNR= </span><span class="si">{</span><span class="n">snr</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Obtained SNR= 88.74 dB
</code></pre></div>

<p>IMPORTANT NOTE: The obtained SNR considering quantization noise sets the theoretical maximum of the signal-to-noise ratio of the converter.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># observe the spectrum</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">fD</span><span class="p">[</span><span class="n">fD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">f_scale</span><span class="p">,</span> <span class="n">dout_db</span><span class="p">[</span><span class="n">fD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">p_scale</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span>   
<span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (KHz)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Dout (dB)&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dout Frequency Spectrum - Quantization Noise Superposition&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;Dout Frequency Spectrum - Quantization Noise Superposition&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_5_files/practical_class_5_29_1.png" /></p>
<h2 id="total-output-noise">Total Output Noise</h2>
<p align="justify">
When modelling a converter, the identified "independant" noise soruces must be superposed to the converter's output signal, in order to obtain an accurate measurement of its SNR and linearity, as exemplified in the image below regarding the high-level model of an ideal ADC with superposed noise sources to develop a non-ideal model.
</p>

<p align="center">
<img src="./imgs/total_output_noise.png" width=400>
</p>

<h1 id="modelling-of-resistive-dacs-at-element-level">Modelling of Resistive DACs at element level</h1>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="c1"># mathematical computing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span> <span class="c1"># to observe the noise signal&#39;s histogram</span>

<span class="n">sns</span><span class="o">.</span><span class="n">set_theme</span><span class="p">()</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set_palette</span><span class="p">(</span><span class="s2">&quot;colorblind&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">normal</span> <span class="c1"># random numbers fitted into a uniform distribution</span>
<span class="c1"># plotting</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># import the models and utilities functions</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">ideal_dac</span><span class="p">,</span> <span class="n">ideal_adc</span><span class="p">,</span> <span class="n">nonideal_adc</span><span class="p">,</span> <span class="n">dec2bin</span><span class="p">,</span> <span class="n">bin2dec</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</code></pre></div>

<h2 id="modelling-of-a-thermometer-code-dac">Modelling of a Thermometer Code DAC</h2>
<p align="center">
    <img src="./imgs/thermometer_dac.png" alt="thermometer-dac" width="300">
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># set up the DAC parameters</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># V</span>
<span class="n">nbits</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># number of bits</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span> <span class="c1"># V</span>
<span class="c1"># number of simulation points</span>
<span class="n">Np</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="c1"># define the time base</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="c1"># Hz</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span> <span class="c1"># s</span>
<span class="n">tD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Ts</span><span class="p">;</span> <span class="c1"># (0:Np-1) == np.arange(0,Np)</span>
<span class="c1"># setup the input codes</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>
<span class="n">f1</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># Hz</span>
<span class="n">ph1</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># rad</span>
<span class="n">ofst</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">si</span> <span class="o">=</span> <span class="n">A1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f1</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">ph1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofst</span> <span class="o">+</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>
<span class="c1"># get the codes from the ideal DAC</span>
<span class="n">incodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">si</span><span class="o">/</span><span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="c1"># represent the input signal and codes</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;input signal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">incodes</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">f1</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">f1</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_3_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># model the resistor ladder</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># ohm - unit resistance</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 5% of the unit resistance for a semiconductor resistor</span>
<span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="n">r_err</span><span class="o">*</span><span class="n">ru</span>
<span class="c1"># show the resistor values</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;resistor value (ohm)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;resistor values distribution&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;resistor values distribution&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_4_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the DAC output voltage for each input code, considering the errors in the resistors</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="n">vout_nonideal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="n">code</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">])</span>
<span class="c1"># observe the DAC transfer function</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span><span class="n">vout_nonideal</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DAC output&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;output voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;DAC transfer function&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;DAC transfer function&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_5_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the DNL and INL of the DAC featuring the resistor mismatch</span>
<span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout_nonideal</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span>
<span class="c1"># plot the DNL and INL</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dnl</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DNL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;DNL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;INL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;INL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_6_0.png" /></p>
<p>As it is possible to observe, the DAC is sensitive to resistor mismatch, severely impacting its INL, which translates in vlasb errors when producing the output voltage. Let us now compute the effective resolution of 100 thermometer ladder DAC converters for a random resistor mismatch following a normal distribution, and check the histogram of the effective resolution of the DACs. This is a very common analysis to check the impact of device mismatch on the performance of a converter circuit.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># generate several ladder circuits, with random resistance wheights every time, and observe the histogram of </span>
<span class="c1"># the resolution of the DAC</span>
<span class="n">ncircuits</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">dac_res</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># measure the effective resolution for each of the circuits</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 5% of the unit resistance for a semiconductor resistor</span>
<span class="k">for</span> <span class="n">circ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncircuits</span><span class="p">):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
    <span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="n">r_err</span><span class="o">*</span><span class="n">ru</span>
    <span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
    <span class="n">vout_nonideal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="n">code</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">])</span>
    <span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout_nonideal</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="c1"># compute the effective number of bits of the DAC using the INL (once the lost bits can be compute by the </span>
    <span class="c1"># difference between the minimum and maximum value of the INL)</span>
    <span class="n">dac_linearity</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inl</span><span class="p">))</span>
    <span class="n">dac_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dac_linearity</span><span class="p">)</span>
<span class="c1"># plot the histogram of the effective number of bits of the DAC</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">dac_res</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;effective number of bits&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density function of each circuit&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;DAC resolution distribution against resistor mismatch&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;DAC resolution distribution against resistor mismatch&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_8_1.png" /></p>
<p>Let us now consider the dynamic operation of the DAC. Let us assume that at the DAC's output voltage is charging a parasitic capacitor of 0.1 pF, and the DAC is clocked at 1 MHz. Naturally, due to the output node pole defined by its RC time constant, the output voltage will not change instantaneously, but will follow a step response. Three main questions arise:
- 1 - How long does it take to charge the output capacitance to 95% of the final value of the output voltage?
- 2 - What impact does the unitary resistances of the DAC have on the output voltage step response?
- 3 - What impact do the switches have on the output voltage step response?
- 
Let us answer those questions in this section.</p>
<p>The settling error can be computed through:
$$
\begin{align}
\epsilon_{S} &amp;= \frac{V^*<em out="out">{out} - V</em>}{V_{out}} = e^{-\frac{T_{CLK}}{\tau}} \
\end{align}
$$</p>
<p>where $V_{out} = V_{REF}\frac{R2}{R2 + R1}$ is the ideal output voltage at the end of the half-clock period, and $V^<em><em REF="REF">{out}(t) = V</em>\frac{R2}{R2 + R1}(1-e^{-\frac{t}{\tau}})$ is the actual observed final output voltage. The RC time constant of the output node is given by:
$$
\begin{align}
\tau &amp;= (C_L + C_P)</em>( R1 // R2 + R_{SW}) \hspace{4pt} \text{(s)}
\end{align}
$$</p>
<p>where $C_L$ is the load capacitance, $C_P$ is the node parasitic capacitance, $R1$ and $R2$ are the top and bottom equivalent resistances of the DAC ladder, and $R_{SW}$ is the switch ON resistance.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># plot the ideal step response</span>
<span class="n">vo</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t_</span><span class="p">,</span> <span class="n">vr_</span><span class="p">,</span> <span class="n">r1_</span><span class="p">,</span> <span class="n">r2_</span><span class="p">,</span> <span class="n">tau_</span><span class="p">:</span> <span class="n">vr_</span><span class="o">*</span><span class="n">r2_</span><span class="o">/</span><span class="p">(</span><span class="n">r1_</span><span class="o">+</span><span class="n">r2_</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="o">-</span><span class="n">t_</span><span class="o">/</span><span class="n">tau_</span><span class="p">)))</span>
<span class="c1"># compute the step respose for a transition between code 0 and code 1</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">CL</span> <span class="o">=</span> <span class="mf">1e-12</span> <span class="c1"># F - load capacitance</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># ohm - unit resistance</span>
<span class="n">num_rus</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">rus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_rus</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
<span class="n">r_sw</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># ohm - switch resistance</span>
<span class="n">cp_sw</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">CL</span> <span class="c1"># F - switch capacitance</span>
<span class="n">fclk</span> <span class="o">=</span> <span class="mf">100e6</span> <span class="c1"># 100 MHz - clock frequency</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">ru</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rus</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span>
    <span class="n">req1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># equivalent resistance of the top of the ladder for code 0</span>
    <span class="n">req2</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># equivalent resistance of the bottom of the ladder for code 1</span>
    <span class="n">tclk</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fclk</span> <span class="c1"># s - clock period -&gt; maximum settling time</span>
    <span class="n">tauu</span> <span class="o">=</span> <span class="p">(</span><span class="n">CL</span> <span class="o">+</span> <span class="n">cp_sw</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">req1</span><span class="o">*</span><span class="n">req2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">req1</span><span class="o">+</span><span class="n">req2</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_sw</span><span class="p">)</span> <span class="c1"># tau ~= (CL + Cp)*( R1//R2 + Rsw )</span>
    <span class="n">vout_t</span> <span class="o">=</span> <span class="n">vo</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">req1</span><span class="p">,</span> <span class="n">req2</span><span class="p">,</span> <span class="n">tauu</span><span class="p">)</span>
    <span class="c1"># compute stelling error</span>
    <span class="n">err_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tclk</span><span class="o">/</span><span class="n">tauu</span><span class="p">)</span> <span class="c1"># err _settling = [(vout - vout_ideal)/vout_ideal] = e^(-tclk/tau)</span>
    <span class="n">err_set_pct</span> <span class="o">=</span> <span class="n">err_set</span><span class="o">*</span><span class="mi">100</span>
    <span class="c1">#print(&#39;tau = {:.2e} s&#39;.format(tauu))</span>
    <span class="c1">#print(&quot;tclk = {:.2e} s&quot;.format(tclk))</span>
    <span class="c1">#print(&quot;tclk/tau = {:.2f}&quot;.format(tclk/tauu))</span>
    <span class="c1">#print(&quot;tclk/Ts = {:.2f}&quot;.format(tclk/Ts))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">vout_t</span><span class="o">/</span><span class="n">vlsb</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;R = </span><span class="si">{:.1e}</span><span class="s1"> k&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;$\Omega$&#39;</span>\
        <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Settling Error = </span><span class="si">{:.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err_set_pct</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (ns)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">tD</span><span class="o">/</span><span class="mf">1e-9</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;voltage (LSBs)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;step response for a transition</span><span class="se">\n</span><span class="s1"> between code 0 and code 1&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tclk</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="o">/</span><span class="k">var</span><span class="o">/</span><span class="n">folders</span><span class="o">/</span><span class="n">vv</span><span class="o">/</span><span class="n">xctyh4bd2td6k2w_gvh_t2vr0000gn</span><span class="o">/</span><span class="n">T</span><span class="o">/</span><span class="n">ipykernel_83439</span><span class="o">/</span><span class="mf">1943781312.</span><span class="n">py</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="w"> </span><span class="n">UserWarning</span><span class="p">:</span><span class="w"> </span><span class="n">set_ticklabels</span><span class="p">()</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">ticks</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">set_ticks</span><span class="p">()</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">FixedLocator</span><span class="o">.</span><span class="w"></span>
<span class="w">  </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">tD</span><span class="o">/</span><span class="mf">1e-9</span><span class="p">)</span><span class="w"></span>





<span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1e-08</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_10_2.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># observe the delay of the DAC agains the code transition</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># ohm - unit resistance</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
<span class="n">tauu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">(</span><span class="n">CL</span><span class="o">+</span><span class="n">cp_sw</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="n">code</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">code</span><span class="p">:]))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="n">code</span><span class="p">])</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">code</span><span class="p">:]))</span> <span class="o">+</span> <span class="n">r_sw</span><span class="p">)</span> <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="p">])</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tauu</span><span class="o">/</span><span class="n">tclk</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DAC delay&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\tau / T_</span><span class="si">{CLK}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;DAC Output RC Delay vs. Input Code Transistion&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;DAC Output RC Delay vs. Input Code Transistion&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_11_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the static power dissipation of the DAC</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># ohm - unit resistance</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
<span class="n">PD</span> <span class="o">=</span> <span class="p">(</span><span class="n">vref</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span><span class="p">)</span> <span class="c1"># W - static power dissipation of the DAC</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PD = </span><span class="si">{:.2f}</span><span class="s1"> uW&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">PD</span><span class="o">/</span><span class="mf">1e-6</span><span class="p">))</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>PD = 3.91 uW
</code></pre></div>

<p>One conclusion that we can retrieve from the previous analysis is that in order to reduce the overall delay of the DAC, we should reduce the RC time constant of the output node by reducing the unitary resistance of the unit resistor of the ladder. However, the lower the unitary resistance, the higher will be the mismatch sensitivity of the DAC, as well as the total static dissipated power of the thermometer ladder DAC. </p>
<p>This observation holds true in general, for all DAC and ADC architectures. The total dissipated power of converters will innevitably be higher when aiming for a converters that present a lower settling error and operate at faster conversion steps.</p>
<h2 id="modelling-of-a-binary-weighted-resistor-dac">Modelling of a Binary Weighted Resistor DAC</h2>
<p align="center">
    <img src="./imgs/bin_weight_res_dac.png" alt="binary-weighted-resistor-dac" width="400">
</p>

<p align="justify">
NOTE: B0 is most significant bit of the DAC, associated with the lowest resistor value in the resistor array,
and subsequnetly to the highest voltage output change when the bit is toggled.
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># set up the DAC parameters</span>
<span class="n">vref</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># V</span>
<span class="n">vdd</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># V</span>
<span class="n">nbits</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># number of bits</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vref</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># V</span>
<span class="c1"># number of simulation points</span>
<span class="n">Np</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="c1"># define the time base</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="c1"># Hz</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span> <span class="c1"># s</span>
<span class="n">tD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Ts</span><span class="p">;</span> <span class="c1"># (0:Np-1) == np.arange(0,Np)</span>
<span class="c1"># setup the input codes</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">vdd</span><span class="o">/</span><span class="mi">2</span>
<span class="n">f1</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># Hz</span>
<span class="n">ph1</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># rad</span>
<span class="n">ofst</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">si</span> <span class="o">=</span> <span class="n">A1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f1</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">ph1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofst</span> <span class="o">+</span> <span class="n">vdd</span><span class="o">/</span><span class="mi">2</span>
<span class="c1"># get the codes from the ideal DAC</span>
<span class="n">incodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">si</span><span class="o">/</span><span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="c1"># represent the input signal and codes</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;input signal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">incodes</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">f1</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">f1</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_15_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># model the binary wheighted resistors</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># ohm - unit resistance</span>
<span class="c1"># create the binary weighted resistors </span>
<span class="n">R_ideal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ru</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbits</span><span class="p">)])</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 5% of the unit resistance for a semiconductor resistor</span>
<span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span> <span class="o">+</span> <span class="n">r_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">R_ideal</span><span class="p">)])</span>
<span class="c1"># feedback resistor </span>
<span class="n">rf</span> <span class="o">=</span> <span class="n">ru</span><span class="o">/</span><span class="mi">2</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">r_err</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;resistor std error (%)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;resistor values distribution&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;resistor values distribution&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_16_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># convert the codes from decimal to binary,</span>
<span class="c1"># and get the indexes of the resistor </span>
<span class="c1"># conducting the current</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="n">incodes_bin</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;codes : &quot;</span><span class="p">,</span> <span class="n">incodes_bin</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;resistors : &quot;</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;NOTE:</span>
<span class="sd">The Most Significant Bit (MSB) is associated with the smallest resistor</span>
<span class="sd">of the array in the DAC ( the unit resistor Ru ). This makes sense for </span>
<span class="sd">a very simple reason: the MSB is associated with the highest voltage change in the </span>
<span class="sd">DAC, and consequently it has to be associated with the highest change in the current </span>
<span class="sd">flowing through the feedback resistor - which is true, once the lowest resistor of the DAC array</span>
<span class="sd">will be the one generating the highest current.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># get transconductances </span>
<span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">R</span><span class="p">])</span>
<span class="c1"># for each code, compute the output voltage</span>
<span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">incodes_bin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">currents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="n">vref</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">icodes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">icodes</span> <span class="ow">in</span> <span class="n">incodes_bin</span>
<span class="p">])</span>
<span class="c1"># plot currents vs. codes</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">currents</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;currents&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;currents (A)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">vout_nonideal</span> <span class="o">=</span> <span class="o">-</span><span class="n">currents</span><span class="o">*</span><span class="n">rf</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>codes :  [[0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 1]
 [0 0 0 ... 0 1 0]
 ...
 [1 1 1 ... 1 0 1]
 [1 1 1 ... 1 1 0]
 [1 1 1 ... 1 1 1]]
resistors :  [  103.89761329   208.86268787   425.05776991   837.72473922
  1469.36913165  2893.90732342  6128.55060707 13684.86859828]
[13684.86859828]
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_17_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># plot the trasnfer function of the DAC</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">vout_nonideal</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DAC transfer function&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;output voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Binary Weighted Resistor DAC Transfer Function&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;Binary Weighted Resistor DAC Transfer Function&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_18_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the DNL and INL of the DAC featuring the resistor mismatch</span>
<span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout_nonideal</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span>
<span class="c1"># plot the DNL and INL</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dnl</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DNL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;DNL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;INL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;INL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_19_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># generate several binary weighted resistor</span>
<span class="c1"># circuits, with random resistance wheights </span>
<span class="c1"># every time, and observe the histogram of </span>
<span class="c1"># the resolution of the DAC</span>
<span class="n">ncircuits</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">dac_res</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># measure the effective resolution for each of the circuits</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 15% of the unit resistance for a semiconductor resistor</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="c1"># get the binary codes</span>
<span class="n">incodes_bin</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
<span class="k">for</span> <span class="n">circ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncircuits</span><span class="p">):</span>
    <span class="n">R_ideal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ru</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)])</span>
    <span class="c1"># feedback resistor</span>
    <span class="n">rf</span> <span class="o">=</span> <span class="n">R_ideal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># resistor array</span>
    <span class="n">R_ideal</span> <span class="o">=</span> <span class="n">R_ideal</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
    <span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># 15% of the unit resistance for a semiconductor resistor</span>
    <span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R_ideal</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">R_ideal</span><span class="p">,</span> <span class="n">r_err</span><span class="p">)</span>
    <span class="c1"># get the transconductances</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">R</span><span class="p">])</span>
    <span class="c1"># get the currents</span>
    <span class="n">currents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">vref</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">icodes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">icodes</span> <span class="ow">in</span> <span class="n">incodes_bin</span><span class="p">])</span>
    <span class="n">vout_nonideal</span> <span class="o">=</span> <span class="o">-</span><span class="n">currents</span><span class="o">*</span><span class="n">rf</span>
    <span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout_nonideal</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="c1"># compute the effective number of bits of the DAC using the INL (once the lost bits can be compute by the </span>
    <span class="c1"># difference between the minimum and maximum value of the INL)</span>
    <span class="n">dac_linearity</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inl</span><span class="p">))</span>
    <span class="n">dac_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dac_linearity</span><span class="p">)</span>
<span class="c1"># plot the histogram of the effective number of bits of the DAC</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">dac_res</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;effective number of bits&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density function of each circuit&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;DAC resolution distribution against resistor mismatch&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;DAC resolution distribution against resistor mismatch&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_20_1.png" /></p>
<p align="justify">
As it is possible to observe, the binary weighted resistor DAC is much more sensitive to resistor mismatch than the thermometer ladder DAC. This is due to the fact the higher is the resistor's resistance, the higher will be the deviation (in iohms) from the ideal value, although it is the same in terms of percentage. As such, transistions associated with input codes featuring changes in the least significant bits will be more sensitive to resistor mismatch than transistions associated with input codes featuring changes only in the most significant bits. 
</p>

<h3 id="reducing-mismatch-sensitivity-of-binary-weighted-resistor-arrays">Reducing mismatch sensitivity of binary weighted resistor arrays</h3>
<p align="justify">
In practice, one way to reduce the mismatch sensitivity of the DAC is to correctly design the resistor array in the circuit's layout. Instead of using variable length polysilicon resistors, a single fixed length and width resistor is used for the highest resistor of the array, and the subsequent resistors are implemented as a parallel combination a a power-of-two number of this highest resistance resistor to make the smaller resistors of the array. Because the standard deviation of the mismatch value of the highest resistor is the same for all the resistors of the array, the mismatch sensitivity of the DAC is reduced once the effective mismatch of the smaller resistors (made by parallel combinations of the resistor with the highest mismatch) decreases.
</p>

<p>Of course that the tradeoff is the in-silicon occupied area. In the classic configuration there are N resistors in the array for a DAC with N bits of resolution, whereas in the proposed configuration there are $2^{N} - 1$ resistors in the array for a DAC with N bits of resolution.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># generate several binary weighted resistor</span>
<span class="c1"># circuits, with random resistance wheights </span>
<span class="c1"># every time, and observe the histogram of </span>
<span class="c1"># the resolution of the DAC</span>
<span class="n">ncircuits</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">dac_res</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># measure the effective resolution for each of the circuits</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mf">2e3</span> <span class="c1"># unit resistance in ohm</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 33% of the unit resistance for a semiconductor resistor</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="c1"># get the binary codes</span>
<span class="n">incodes_bin</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
<span class="k">for</span> <span class="n">circ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncircuits</span><span class="p">):</span>
    <span class="c1"># generate the array of resistors made with parallel combinations of the unit resistor</span>
    <span class="c1"># NOTE that in this layout configuration, there are 2**nbits - 1 resistors in the array</span>
    <span class="c1"># whereas in the previous configuration there were nbits resistors</span>
    <span class="n">R_ideal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ru</span>
    <span class="n">R_idxs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="nb">id</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="nb">id</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbits</span><span class="p">)}</span>
    <span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># 15% of the unit resistance for a semiconductor resistor</span>
    <span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R_ideal</span><span class="p">))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R_ideal</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">R_ideal</span><span class="p">,</span> <span class="n">r_err</span><span class="p">)</span>
    <span class="c1"># generate the binary weighted resistor array from </span>
    <span class="c1"># the unit resistor in parallel combinations</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">R_idxs</span><span class="p">[</span><span class="nb">id</span><span class="p">]]))</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbits</span><span class="p">)])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># reverse the array to associate the MSB to lowest resistance resistor</span>
    <span class="c1"># feedback resistor</span>
    <span class="n">rf</span> <span class="o">=</span> <span class="n">ru</span><span class="o">/</span><span class="mi">2</span>
    <span class="c1"># get the transconductances</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">R</span><span class="p">])</span>
    <span class="c1"># get the currents</span>
    <span class="n">currents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">vref</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">icodes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">icodes</span> <span class="ow">in</span> <span class="n">incodes_bin</span><span class="p">])</span>
    <span class="n">vout_nonideal</span> <span class="o">=</span> <span class="o">-</span><span class="n">currents</span><span class="o">*</span><span class="n">rf</span>
    <span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout_nonideal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout_nonideal</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="c1"># compute the effective number of bits of the DAC using the INL (once the lost bits can be compute by the </span>
    <span class="c1"># difference between the minimum and maximum value of the INL)</span>
    <span class="n">dac_linearity</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inl</span><span class="p">))</span>
    <span class="n">dac_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dac_linearity</span><span class="p">)</span>
<span class="c1"># plot the histogram of the effective number of bits of the DAC</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">dac_res</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;effective number of bits&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density function of each circuit&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;DAC resolution distribution against resistor mismatch&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;DAC resolution distribution against resistor mismatch&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_22_1.png" /></p>
<p align="justify">
From the above histogram, is possible to observe that the implementation of the binary weighted resistor array 
designed through parallel combinations of the highest unitary resistor of the array enables the reduction of the mismatch sensitivity of the DAC, increasing the effective resolution of the DAC.
</p>

<h2 align="left"> Modelling a R-2R DAC </h2>

<p align="center">
<img src="./imgs/r_2r_dac.png" width=500>
</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># set up the DAC parameters</span>
<span class="n">vref</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># V</span>
<span class="n">nbits</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># number of bits</span>
<span class="n">vlsb</span> <span class="o">=</span> <span class="n">vref</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span> <span class="c1"># V</span>
<span class="c1"># number of simulation points</span>
<span class="n">Np</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="c1"># define the time base</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="c1"># Hz</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span> <span class="c1"># s</span>
<span class="n">tD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Np</span><span class="p">)</span><span class="o">*</span><span class="n">Ts</span><span class="p">;</span> <span class="c1"># (0:Np-1) == np.arange(0,Np)</span>
<span class="c1"># setup the input codes</span>
<span class="n">A4</span> <span class="o">=</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>
<span class="n">f4</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c1"># Hz</span>
<span class="n">ph4</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># rad</span>
<span class="n">ofst</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">si</span> <span class="o">=</span> <span class="n">A4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f4</span><span class="o">*</span><span class="n">tD</span> <span class="o">+</span> <span class="n">ph4</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofst</span> <span class="o">+</span> <span class="n">vref</span><span class="o">/</span><span class="mi">2</span>
<span class="c1"># get the codes from the ideal DAC</span>
<span class="n">incodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">si</span><span class="o">/</span><span class="n">vlsb</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="c1"># represent the input signal and codes</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;input signal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tD</span><span class="p">,</span> <span class="n">incodes</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">f4</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">f4</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_26_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># model the binary wheighted resistors</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># ohm - unit resistance</span>
<span class="c1"># vertical resistors = 2*Ru</span>
<span class="n">rv</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">ru</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbits</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># horizontal resistors = Ru</span>
<span class="n">rh</span> <span class="o">=</span> <span class="n">ru</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 5% of the unit resistance for a semiconductor resistor</span>
<span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="n">nbits</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Rv</span> <span class="o">=</span> <span class="n">rv</span> <span class="o">+</span> <span class="n">rv</span><span class="o">*</span><span class="n">r_err</span>
<span class="n">Rg</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Rv</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Rh</span> <span class="o">=</span> <span class="n">rh</span> <span class="o">+</span> <span class="n">rh</span><span class="o">*</span><span class="n">r_err</span>
<span class="c1"># feedback resistor </span>
<span class="n">Rf</span> <span class="o">=</span> <span class="n">ru</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span>
<span class="n">Rf</span><span class="p">,</span> <span class="n">Rg</span><span class="p">,</span> <span class="n">Rv</span><span class="p">,</span> <span class="n">Rh</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>(25600,
 np.float64(208.49751019090903),
 array([213.5285145 , 193.90647816, 194.17099207, 197.25946699,
        208.11691498, 230.17619108, 196.78889373, 211.35284485]),
 array([ 95.06471546, 107.93773213, 111.49062744,  97.86837209,
        100.23190548, 104.43222349,  97.47375927]))
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;resistance (Ohm)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;vertical resistor</span><span class="se">\n</span><span class="s1">values distribution&#39;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">Rh</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;resistance (Ohm)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;horizontal resistor</span><span class="se">\n</span><span class="s1">values distribution&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;horizontal resistor\nvalues distribution&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_28_1.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">pdb</span>

<span class="n">nodeVolt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbits</span><span class="p">)</span><span class="c1"># node voltages, from lsb to msb</span>
<span class="n">reqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbits</span><span class="p">)</span><span class="c1"># equivalent resistances at each node, from lsb to msb</span>
<span class="c1"># setup the equivalent resistances</span>
<span class="n">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rg</span><span class="o">*</span><span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">Rg</span><span class="o">+</span><span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># define the vectorizable resistance function to </span>
<span class="c1"># compute the equivalent resistance at each node</span>

<span class="k">def</span> <span class="nf">reqf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Rv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Rh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Req</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">Req</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Rh</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">Req</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">Rv</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">Rh</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Rv</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">+</span> <span class="n">Req</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">reqfp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">reqf</span><span class="p">,</span> <span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">,</span> <span class="n">Rh</span><span class="o">=</span><span class="n">Rh</span><span class="p">,</span> <span class="n">Req</span><span class="o">=</span><span class="n">reqs</span><span class="p">)</span>
<span class="c1"># vectorize the function</span>
<span class="n">reqvf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">reqfp</span><span class="p">)</span>
<span class="n">reqvf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nbits</span><span class="p">))</span> <span class="c1"># compute the equivalent resistances at each node</span>
<span class="c1"># compute the node voltages </span>
<span class="n">nodeVolt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">vref</span>
<span class="k">def</span> <span class="nf">vnf</span><span class="p">(</span><span class="n">node</span> <span class="p">,</span> <span class="n">nodeVolt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Req</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Rh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">nodeVolt</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeVolt</span><span class="p">[</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">Req</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">Req</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">+</span><span class="n">Rh</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
<span class="n">vnfp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vnf</span><span class="p">,</span> <span class="n">nodeVolt</span><span class="o">=</span><span class="n">nodeVolt</span><span class="p">,</span> <span class="n">Req</span><span class="o">=</span><span class="n">reqs</span><span class="p">,</span> <span class="n">Rh</span><span class="o">=</span><span class="n">Rh</span><span class="p">)</span>
<span class="n">vnvf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">vnfp</span><span class="p">)</span>
<span class="n">vnvf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># compute the node voltages at each node</span>
<span class="n">nodeVolt</span> <span class="o">=</span> <span class="n">nodeVolt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># flip</span>
<span class="c1"># compute the equivalent currents at each vertical resistor in case the bit is ON</span>
<span class="n">currents</span> <span class="o">=</span> <span class="n">nodeVolt</span> <span class="o">/</span> <span class="n">Rv</span>

<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="n">incodes_bin</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
<span class="c1"># compute the output currents for each input code </span>
<span class="n">current_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">currents</span><span class="p">[</span><span class="n">incode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">incode</span> <span class="ow">in</span> <span class="n">incodes_bin</span><span class="p">])</span>
<span class="c1"># compute the output voltage for each input code</span>
<span class="n">vout</span> <span class="o">=</span> <span class="o">-</span><span class="n">current_out</span><span class="o">*</span><span class="n">Rf</span>
<span class="n">reqs</span><span class="p">,</span> <span class="n">nodeVolt</span><span class="p">,</span> <span class="n">Rv</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>(array([105.49151243,  98.58765157, 100.07886536, 102.08201836,
        101.97596783, 107.64374064, 102.07332219, 102.64018231]),
 array([-1.        , -0.51152501, -0.25963558, -0.13093748, -0.06684839,
        -0.03162134, -0.01509487, -0.00793982]),
 array([213.5285145 , 193.90647816, 194.17099207, 197.25946699,
        208.11691498, 230.17619108, 196.78889373, 211.35284485]))
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># observe the node voltages and equivalent resistances at each node</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbits</span><span class="p">),</span> <span class="n">nodeVolt</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;node voltages&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbits</span><span class="p">),</span> <span class="n">reqs</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;equivalent resistances&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;resistance (Ohm)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reqs</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;mean= </span><span class="si">{:.2f}</span><span class="s1"> Ohm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reqs</span><span class="p">)))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_30_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># observe both the input and output codes</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">current_out</span><span class="o">/</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;output current (mA)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">vout</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;output voltage (V)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_31_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># compute the DNL and INL, and the effective number of bits of the DAC</span>
<span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">inl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># check if the INL is zero in its first and last index</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">inl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># check if the DNL is zero in its last index</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">nbits</span>
<span class="c1"># compute the effective number of bits of the DAC</span>
<span class="n">dac_linearity</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inl</span><span class="p">))</span>
<span class="n">dac_linearity</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>np.float64(4.031796695679045)
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># plot the DNL and INL</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dnl</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;DNL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;DNL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;INL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;input codes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;INL&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_33_0.png" /></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># generate several binary weighted resistor</span>
<span class="c1"># circuits, with random resistance wheights </span>
<span class="c1"># every time, and observe the histogram of </span>
<span class="c1"># the resolution of the DAC</span>
<span class="n">ncircuits</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">dac_res</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># measure the effective resolution for each of the circuits</span>
<span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
<span class="n">ru</span> <span class="o">=</span> <span class="mf">2e3</span> <span class="c1"># unit resistance in ohm</span>
<span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 15% of the unit resistance for a semiconductor resistor</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
<span class="c1"># get the binary codes</span>
<span class="n">incodes_bin</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>

<span class="k">for</span> <span class="n">circ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncircuits</span><span class="p">):</span>
    <span class="c1"># model the resistors</span>
    <span class="n">ru</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># ohm - unit resistance</span>
    <span class="c1"># vertical resistors = 2*Ru</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">ru</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbits</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># horizontal resistors = Ru</span>
    <span class="n">rh</span> <span class="o">=</span> <span class="n">ru</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># resistance mismatch in ohm, following a normal distribution</span>
    <span class="n">u_err</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># consider : 1 sigma, 2 sigma or 3 sigma (wrost case scenario)</span>
    <span class="n">u_std</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># 15% of the unit resistance for a semiconductor resistor</span>
    <span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="n">nbits</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Rv</span> <span class="o">=</span> <span class="n">rv</span> <span class="o">+</span> <span class="n">rv</span><span class="o">*</span><span class="n">r_err</span>
    <span class="n">Rg</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Rv</span> <span class="o">=</span> <span class="n">Rv</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_err</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">u_err</span><span class="p">,</span> <span class="n">u_std</span><span class="p">,</span> <span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Rh</span> <span class="o">=</span> <span class="n">rh</span> <span class="o">+</span> <span class="n">rh</span><span class="o">*</span><span class="n">r_err</span>
    <span class="c1"># feedback resistor </span>
    <span class="n">Rf</span> <span class="o">=</span> <span class="n">ru</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span>

    <span class="n">nodeVolt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbits</span><span class="p">)</span><span class="c1"># node voltages, from lsb to msb</span>
    <span class="n">reqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbits</span><span class="p">)</span><span class="c1"># equivalent resistances at each node, from lsb to msb</span>
    <span class="c1"># setup the equivalent resistances</span>
    <span class="n">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rg</span><span class="o">*</span><span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">Rg</span><span class="o">+</span><span class="n">Rv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># define the vectorizable resistance function to </span>
    <span class="c1"># compute the equivalent resistance at each node</span>
    <span class="n">reqfp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">reqf</span><span class="p">,</span> <span class="n">Rv</span><span class="o">=</span><span class="n">Rv</span><span class="p">,</span> <span class="n">Rh</span><span class="o">=</span><span class="n">Rh</span><span class="p">,</span> <span class="n">Req</span><span class="o">=</span><span class="n">reqs</span><span class="p">)</span>
    <span class="c1"># vectorize the function</span>
    <span class="n">reqvf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">reqfp</span><span class="p">)</span>
    <span class="n">reqvf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nbits</span><span class="p">))</span> <span class="c1"># compute the equivalent resistances at each node</span>
    <span class="c1"># compute the node voltages </span>
    <span class="n">nodeVolt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">vref</span>

    <span class="n">vnfp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">vnf</span><span class="p">,</span> <span class="n">nodeVolt</span><span class="o">=</span><span class="n">nodeVolt</span><span class="p">,</span> <span class="n">Req</span><span class="o">=</span><span class="n">reqs</span><span class="p">,</span> <span class="n">Rh</span><span class="o">=</span><span class="n">Rh</span><span class="p">)</span>
    <span class="n">vnvf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">vnfp</span><span class="p">)</span>
    <span class="n">vnvf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># compute the node voltages at each node</span>
    <span class="n">nodeVolt</span> <span class="o">=</span> <span class="n">nodeVolt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># flip</span>
    <span class="c1"># compute the equivalent currents at each vertical resistor in case the bit is ON</span>
    <span class="n">currents</span> <span class="o">=</span> <span class="n">nodeVolt</span> <span class="o">/</span> <span class="n">Rv</span>

    <span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="p">)</span>
    <span class="n">incodes_bin</span> <span class="o">=</span> <span class="n">dec2bin</span><span class="p">(</span><span class="n">codes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span>
    <span class="c1"># compute the output currents for each input code </span>
    <span class="n">current_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">currents</span><span class="p">[</span><span class="n">incode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">incode</span> <span class="ow">in</span> <span class="n">incodes_bin</span><span class="p">])</span>
    <span class="c1"># compute the output voltage for each input code</span>
    <span class="n">vout</span> <span class="o">=</span> <span class="o">-</span><span class="n">current_out</span><span class="o">*</span><span class="n">Rf</span>

    <span class="c1"># compute the DNL and INL, and the effective number of bits of the DAC</span>
    <span class="n">vlsb_measured</span> <span class="o">=</span> <span class="p">(</span><span class="n">vout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vout</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dnl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">vout</span><span class="p">)</span><span class="o">/</span><span class="n">vlsb_measured</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">inl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dnl</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="c1"># compute the effective number of bits of the DAC</span>
    <span class="n">dac_linearity</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inl</span><span class="p">))</span>
    <span class="n">dac_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dac_linearity</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">dac_res</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;effective number of bits&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;probability density function of each circuit&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;DAC resolution distribution against resistor mismatch&#39;</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code>Text(0.5, 1.0, &#39;DAC resolution distribution against resistor mismatch&#39;)
</code></pre></div>

<p><img alt="png" src="practical_class_6_files/practical_class_6_35_1.png" /></p>
<p align="justify">
From the above histogram it is possible to observe that although the R-2R DAC uses much less hardware, drastically reducing the number of resistors to 2N + 1, it is much more sensitive to resistor mismatch than the binary weighted resistor DAC. The decreasing voltage at each successive node of the R-2R array is successively more sensitive to resistor mismatch, as the mismatch at higher voltage nodes is much more critical than the mismatch at lower voltage nodes.
</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../mathjaxhelper.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
