{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Analog / Mixed-Signal IC Engineer PhD candidate at NOVA-UNL / TU Delft Welcome. This is a personal website built on top of MkDocs . Hi! My name is Diogo Andr\u00e9. I'm currently pursuing a PhD in Nanoelectronics under a mixed-scholarship at NOVA University of Lisbon, School of Science and Technology (Monte da Caparica, Portugal), and TU Delft, Bioelectronics Group (Delft, The Netherlands). I'm specialising in Analog / Mixed-Signal IC Design, focusing on Analog Front-Ends and Quantizer ASIC Interfaces for Ultrasound Imaging Transducer Arrays. I am also a big fan of using C-lang and Python to develop my own tools for automatic layout design and custom extractors for parasitic passive lumped elements and crosstalk between signal lines. Feel free to contact me! \ud83d\udcc2 Personal Info \ud83d\udcc5 Nov 19, 1998 \ud83c\udfe0 R. Bento Gon\u00e7alves 68, 2835-674 Barreiro, Portugal E-mail: \ud83d\udce7 das.dias@campus.fct.unl.pt \ud83d\udce7 ddias@tudelft.nl \ud83d\udd17 Google Scholar \ud83d\udd17 GitHub \ud83d\udd17 LinkedIn \ud83c\udf93 Education MSc. in Electrical and Computers Engineering NOVA University of Lisbon (Sep 2019 - Dec 2021) Grade: 17/20 BSc. in Electrical and Computers Engineering NOVA University of Lisbon (Sep 2016 - Jul 2019) Grade: 17/20 \ud83c\udfe2 Experience CMOS Process Development Kits (PDKs) 28 nm (HPC+) TSMC PDK , 130 nm UMC PDK PhD Candidate (ASICs For Ultrasound Image-Guided Vagus Nerve Stimulation) NOVA University of Lisbon, Delft University of Technology (May 2022 - Ongoing) Nyquist Data-Rate Converters Course (Teaching Assistant) Delft University of Technology (Feb - May 2024) Erasmus+ Traineeship Student Delft University of Technology (Feb - Jun 2021) - Master Thesis Dissertation Electronics II Course (Teaching Assistant) NOVA University of Lisbon (Sep - Dec 2019) \ud83d\udcda Research A PVT-Robust Open-loop Gm-Ratio\u00d7 16 Gain Residue Amplifier for> 1 GS/s Pipelined ADCs CTS, LASI, NOVA University of Lisbon (Dec 2023) - IEEE ISCAS \u201924 Publication A Parasitic Resistance Extraction Tool Leveraged by Image Processing PDEEC, NOVA University of Lisbon (Dec 2021) - IEEE ISCAS \u201922 Publication Preliminary Assessment of an Ultrasonic Level Sensor for the Calorimetric Measurement of AC Losses in Superconducting Devices CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - YEF-ECE \u201922 Publication Ultrasound-based Cryogenic Monitoring System for Superconducting Systems CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - EUCAS \u201921 Publication \ud83d\udee0\ufe0f Technical Skills & Tools Cadence - Analog / Mixed-Signal Base-Band & RF IC Design Cadence / KLayout / Python - IC Layout Design Xillinx ISE - Digital IC Design, Verilog MATLAB, Python, C, Verilog MS Office, Git, LaTeX (Mac) OSX, Linux(Ubuntu/CentOS), Windows \ud83c\udfc6 Certifications Artificial Intelligence Course Samsung Innovation Campus at NOVA University of Lisbon (Jun - Sep 2021) \ud83d\udd2c Projects novaad Open-Source Software Contribution - A Python tool for Look-up Table (LUT)-based Gm/Id Analog IC design. gdsfactory/gplugins/spice Open-Source Software Contribution - A Python library for converting between YAML Markup language and SPICE schematic netlist description language. This tool explores the use of modern computer Markup language YAML to represent schematic netlists, allowing for integrated photonic and electronic schematics to co-exist and relate to each other in a single human-readable file. YAML has also readily available Serializer/Deserializer parsers for most common programming languages (C++, C, Python, Ruby, Go, ...). Important Note: both the base source code for the gdsfactory/gplugins/spice and gdsfactory/gplugins/vlsir tools were initially aggregated into a personal repository of mine - parcirc . gdsfactory/gplugins/vlsir Open-Source Software Contribution - A Python library for converting between Klayout's DB Netlist format and other electrical schematic file formats (SPICE, Spectre, Xyce) - More about the tool at: gdsfactory.github.io/gplugins/notebooks/vlsir_netlist This work is supported and inspired by Dan Fritchman's VLSIR Tools work, linking the way PDK information is represented in the older, closed-source custom filesystem formats to new, open-source, supported and maintained file and binary formats that allow for a greater information compression and inter-programming language data-structure sharing and interpretation through the use of Google's Protobuf data interface protocol. I highly encourage you to read more about Dan Fritchman's work . Master Thesis Dissertation NOVA University of Lisbon & Delft University of Technology (Sep 2020 - Dec 2021) - \"On the Use of Image Processing for 3D Parasitic Resistance Networks Extraction in Integrated Circuits\" - Grade: 19/20 Zero-IF FSK RF Receiver Analog Front-End NOVA University of Lisbon (Sep - Dec 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology 120 dB Gain, Low-Voltage (0.9 V supply) Operational Transconductance Amplifier NOVA University of Lisbon (Sep - Nov 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology 66 dB Gain, 100 MHz GBW Fully-Differential Hybrid Telescopic-Folded Cascode Amplifier NOVA University of Lisbon (Nov - Dec 2019) - Designed in 0.13\u00b5m (MM/RF) UMC technology \ud83c\udf0d Languages Portuguese: \u25cb \u25cb \u25cb \u25cb \u25cb English: \u25cb \u25cb \u25cb \u25cb \u25cb Spanish: \u25cb \u25cb \u25cb Dutch: \u25cb \u25cb \ud83c\udfad Extra-Curricular Activities Pedagogical Committee Representative NOVA University of Lisbon (Nov 2019 - Jul 2021) - Electrical and Computers Engineering Department Volunteer Work \u2013 Refood Telheiras, Lisbon Sep - Dec 2019 - Redistribution of food waste \ud83c\udfa8 Hobbies Reading and watching documentaries about History Electric Bass Guitar Half-Marathon Running Contributing to open-source EDA-CAD software","title":"Home"},{"location":"#personal-info","text":"\ud83d\udcc5 Nov 19, 1998 \ud83c\udfe0 R. Bento Gon\u00e7alves 68, 2835-674 Barreiro, Portugal E-mail: \ud83d\udce7 das.dias@campus.fct.unl.pt \ud83d\udce7 ddias@tudelft.nl \ud83d\udd17 Google Scholar \ud83d\udd17 GitHub \ud83d\udd17 LinkedIn","title":"\ud83d\udcc2 Personal Info"},{"location":"#education","text":"","title":"\ud83c\udf93 Education"},{"location":"#msc-in-electrical-and-computers-engineering","text":"NOVA University of Lisbon (Sep 2019 - Dec 2021) Grade: 17/20","title":"MSc. in Electrical and Computers Engineering"},{"location":"#bsc-in-electrical-and-computers-engineering","text":"NOVA University of Lisbon (Sep 2016 - Jul 2019) Grade: 17/20","title":"BSc. in Electrical and Computers Engineering"},{"location":"#experience","text":"","title":"\ud83c\udfe2 Experience"},{"location":"#cmos-process-development-kits-pdks","text":"28 nm (HPC+) TSMC PDK , 130 nm UMC PDK","title":"CMOS Process Development Kits (PDKs)"},{"location":"#phd-candidate-asics-for-ultrasound-image-guided-vagus-nerve-stimulation","text":"NOVA University of Lisbon, Delft University of Technology (May 2022 - Ongoing)","title":"PhD Candidate (ASICs For Ultrasound Image-Guided Vagus Nerve Stimulation)"},{"location":"#nyquist-data-rate-converters-course-teaching-assistant","text":"Delft University of Technology (Feb - May 2024)","title":"Nyquist Data-Rate Converters Course (Teaching Assistant)"},{"location":"#erasmus-traineeship-student","text":"Delft University of Technology (Feb - Jun 2021) - Master Thesis Dissertation","title":"Erasmus+ Traineeship Student"},{"location":"#electronics-ii-course-teaching-assistant","text":"NOVA University of Lisbon (Sep - Dec 2019)","title":"Electronics II Course (Teaching Assistant)"},{"location":"#research","text":"","title":"\ud83d\udcda Research"},{"location":"#a-pvt-robust-open-loop-gm-ratio-16-gain-residue-amplifier-for-1-gss-pipelined-adcs","text":"CTS, LASI, NOVA University of Lisbon (Dec 2023) - IEEE ISCAS \u201924 Publication","title":"A PVT-Robust Open-loop Gm-Ratio\u00d7 16 Gain Residue Amplifier for&gt; 1 GS/s Pipelined ADCs"},{"location":"#a-parasitic-resistance-extraction-tool-leveraged-by-image-processing","text":"PDEEC, NOVA University of Lisbon (Dec 2021) - IEEE ISCAS \u201922 Publication","title":"A Parasitic Resistance Extraction Tool Leveraged by Image Processing"},{"location":"#preliminary-assessment-of-an-ultrasonic-level-sensor-for-the-calorimetric-measurement-of-ac-losses-in-superconducting-devices","text":"CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - YEF-ECE \u201922 Publication","title":"Preliminary Assessment of an Ultrasonic Level Sensor for the Calorimetric Measurement of AC Losses in Superconducting Devices"},{"location":"#ultrasound-based-cryogenic-monitoring-system-for-superconducting-systems","text":"CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - EUCAS \u201921 Publication","title":"Ultrasound-based Cryogenic Monitoring System for Superconducting Systems"},{"location":"#technical-skills-tools","text":"Cadence - Analog / Mixed-Signal Base-Band & RF IC Design Cadence / KLayout / Python - IC Layout Design Xillinx ISE - Digital IC Design, Verilog MATLAB, Python, C, Verilog MS Office, Git, LaTeX (Mac) OSX, Linux(Ubuntu/CentOS), Windows","title":"\ud83d\udee0\ufe0f Technical Skills &amp; Tools"},{"location":"#certifications","text":"","title":"\ud83c\udfc6 Certifications"},{"location":"#artificial-intelligence-course","text":"Samsung Innovation Campus at NOVA University of Lisbon (Jun - Sep 2021)","title":"Artificial Intelligence Course"},{"location":"#projects","text":"","title":"\ud83d\udd2c Projects"},{"location":"#novaad","text":"Open-Source Software Contribution - A Python tool for Look-up Table (LUT)-based Gm/Id Analog IC design.","title":"novaad"},{"location":"#gdsfactorygpluginsspice","text":"Open-Source Software Contribution - A Python library for converting between YAML Markup language and SPICE schematic netlist description language. This tool explores the use of modern computer Markup language YAML to represent schematic netlists, allowing for integrated photonic and electronic schematics to co-exist and relate to each other in a single human-readable file. YAML has also readily available Serializer/Deserializer parsers for most common programming languages (C++, C, Python, Ruby, Go, ...). Important Note: both the base source code for the gdsfactory/gplugins/spice and gdsfactory/gplugins/vlsir tools were initially aggregated into a personal repository of mine - parcirc .","title":"gdsfactory/gplugins/spice"},{"location":"#gdsfactorygpluginsvlsir","text":"Open-Source Software Contribution - A Python library for converting between Klayout's DB Netlist format and other electrical schematic file formats (SPICE, Spectre, Xyce) - More about the tool at: gdsfactory.github.io/gplugins/notebooks/vlsir_netlist This work is supported and inspired by Dan Fritchman's VLSIR Tools work, linking the way PDK information is represented in the older, closed-source custom filesystem formats to new, open-source, supported and maintained file and binary formats that allow for a greater information compression and inter-programming language data-structure sharing and interpretation through the use of Google's Protobuf data interface protocol. I highly encourage you to read more about Dan Fritchman's work .","title":"gdsfactory/gplugins/vlsir"},{"location":"#master-thesis-dissertation","text":"NOVA University of Lisbon & Delft University of Technology (Sep 2020 - Dec 2021) - \"On the Use of Image Processing for 3D Parasitic Resistance Networks Extraction in Integrated Circuits\" - Grade: 19/20","title":"Master Thesis Dissertation"},{"location":"#zero-if-fsk-rf-receiver-analog-front-end","text":"NOVA University of Lisbon (Sep - Dec 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology","title":"Zero-IF FSK RF Receiver Analog Front-End"},{"location":"#120-db-gain-low-voltage-09-v-supply-operational-transconductance-amplifier","text":"NOVA University of Lisbon (Sep - Nov 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology","title":"120 dB Gain, Low-Voltage (0.9 V supply) Operational Transconductance Amplifier"},{"location":"#66-db-gain-100-mhz-gbw-fully-differential-hybrid-telescopic-folded-cascode-amplifier","text":"NOVA University of Lisbon (Nov - Dec 2019) - Designed in 0.13\u00b5m (MM/RF) UMC technology","title":"66 dB Gain, 100 MHz GBW Fully-Differential Hybrid Telescopic-Folded Cascode Amplifier"},{"location":"#languages","text":"Portuguese: \u25cb \u25cb \u25cb \u25cb \u25cb English: \u25cb \u25cb \u25cb \u25cb \u25cb Spanish: \u25cb \u25cb \u25cb Dutch: \u25cb \u25cb","title":"\ud83c\udf0d Languages"},{"location":"#extra-curricular-activities","text":"","title":"\ud83c\udfad Extra-Curricular Activities"},{"location":"#pedagogical-committee-representative","text":"NOVA University of Lisbon (Nov 2019 - Jul 2021) - Electrical and Computers Engineering Department","title":"Pedagogical Committee Representative"},{"location":"#volunteer-work-refood-telheiras-lisbon","text":"Sep - Dec 2019 - Redistribution of food waste","title":"Volunteer Work \u2013 Refood Telheiras, Lisbon"},{"location":"#hobbies","text":"Reading and watching documentaries about History Electric Bass Guitar Half-Marathon Running Contributing to open-source EDA-CAD software","title":"\ud83c\udfa8 Hobbies"},{"location":"computational_electromagnetics/","text":"Coming soon...","title":"Computational Electromagnetics"},{"location":"computational_electromagnetics/#coming-soon","text":"","title":"Coming soon..."},{"location":"misc/","text":"This is a collection of interesting tools, sandboxes and projects I end up doing when I want to learn new things about programming (and more specifically scientific-programming), IC Design how EDA tools for IC design work and can be innovated. Hope you find something that you would like to try for yourself! Programming in C-lang with Jupyter Notebooks Introduction: Hello World! Start by writting your C-lang file: %%file hello_world.c #include <stdio.h> #include <stdlib.h> int main(int argc, char **argv) { printf(\"Hello World from C in Jupyter!\"); exit(0); } Overwriting hello_world.c Now, compile your C code. %%bash gcc --version Apple clang version 15.0.0 (clang-1500.3.9.4) Target: arm64-apple-darwin23.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Compiling the code with the: - -W or --Wall flag is useful, enabling a wide variety of usefull warnings - -Werror treats critical warnings as errors, to make your code bulletproof once debugged. %%bash gcc ./hello_world.c -g -Werror -o hello_world Now, we can finally execute our C code from Jupyter. %%bash ./hello_world Hello World from C in Jupyter! Testing the C program: Python scripting We can now take advantage of having a documentation system with shell and Python scripting capabilities to quickly develop input testing files to run multiple test cases against the C program. This effectively automates the unit testing of the C program. from itertools import permutations inputs = permutations([3, '+', 43]) with open('permutations.in', 'w') as testfile: def str_from_perm(perm: list) -> str: s = str(perm) s = s.replace('(', ''); s = s.replace(')', ''); s = s.replace(\"'\", ''); s = s.replace(',', '') return s + '\\n' [testfile.write(str_from_perm(perm)) for perm in inputs] %cat permutations.in 3 + 43 3 43 + + 3 43 + 43 3 43 3 + 43 + 3 %%file permutations.c #include <stdlib.h> #include <stdio.h> #include <string.h> #include <assert.h> char *expected_tokens[] = {\"3\", \"A\", \"+\", \"6\", \"43\", NULL}; int arg_in_expected_tokens(char *arg, char **tokens){ int found_token_chars = 0; for(char **it_token = tokens; *it_token != NULL; it_token++){ if(!strcmp(arg, *it_token)) return 1; } printf(\"Assertion Failed: %s not in [\", arg); for(char **it_token = tokens; *it_token != NULL; ++it_token) printf(\"%s, \", *it_token); printf(\"]\\n\"); return 0; } int main(int argc, char **argv) { assert(argc>1); for(int i = 1; i < argc; i++) assert(arg_in_expected_tokens(argv[i], expected_tokens)); printf(\"Tests: Passed\\n\"); exit(0); } Overwriting permutations.c %%bash gcc ./permutations.c -g -Werror -o permutations Finally, use bash shell scripting to input all inputs, line by line, to the C programm, so that each test is verified. %%bash echo \"\" > permutations.out cat permutations.in | while read line do ./permutations $line >> permutations.out done %cat permutations.out Tests: Passed Tests: Passed Tests: Passed Tests: Passed Tests: Passed Tests: Passed If you're developing in Linux, you can even use Valgrind to automatically detect many memory management and threading bugs, and profile your programs in detail.","title":"Miscellaneous"},{"location":"misc/#programming-in-c-lang-with-jupyter-notebooks","text":"","title":"Programming in C-lang with Jupyter Notebooks"},{"location":"misc/#introduction-hello-world","text":"Start by writting your C-lang file: %%file hello_world.c #include <stdio.h> #include <stdlib.h> int main(int argc, char **argv) { printf(\"Hello World from C in Jupyter!\"); exit(0); } Overwriting hello_world.c Now, compile your C code. %%bash gcc --version Apple clang version 15.0.0 (clang-1500.3.9.4) Target: arm64-apple-darwin23.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Compiling the code with the: - -W or --Wall flag is useful, enabling a wide variety of usefull warnings - -Werror treats critical warnings as errors, to make your code bulletproof once debugged. %%bash gcc ./hello_world.c -g -Werror -o hello_world Now, we can finally execute our C code from Jupyter. %%bash ./hello_world Hello World from C in Jupyter!","title":"Introduction: Hello World!"},{"location":"misc/#testing-the-c-program-python-scripting","text":"We can now take advantage of having a documentation system with shell and Python scripting capabilities to quickly develop input testing files to run multiple test cases against the C program. This effectively automates the unit testing of the C program. from itertools import permutations inputs = permutations([3, '+', 43]) with open('permutations.in', 'w') as testfile: def str_from_perm(perm: list) -> str: s = str(perm) s = s.replace('(', ''); s = s.replace(')', ''); s = s.replace(\"'\", ''); s = s.replace(',', '') return s + '\\n' [testfile.write(str_from_perm(perm)) for perm in inputs] %cat permutations.in 3 + 43 3 43 + + 3 43 + 43 3 43 3 + 43 + 3 %%file permutations.c #include <stdlib.h> #include <stdio.h> #include <string.h> #include <assert.h> char *expected_tokens[] = {\"3\", \"A\", \"+\", \"6\", \"43\", NULL}; int arg_in_expected_tokens(char *arg, char **tokens){ int found_token_chars = 0; for(char **it_token = tokens; *it_token != NULL; it_token++){ if(!strcmp(arg, *it_token)) return 1; } printf(\"Assertion Failed: %s not in [\", arg); for(char **it_token = tokens; *it_token != NULL; ++it_token) printf(\"%s, \", *it_token); printf(\"]\\n\"); return 0; } int main(int argc, char **argv) { assert(argc>1); for(int i = 1; i < argc; i++) assert(arg_in_expected_tokens(argv[i], expected_tokens)); printf(\"Tests: Passed\\n\"); exit(0); } Overwriting permutations.c %%bash gcc ./permutations.c -g -Werror -o permutations Finally, use bash shell scripting to input all inputs, line by line, to the C programm, so that each test is verified. %%bash echo \"\" > permutations.out cat permutations.in | while read line do ./permutations $line >> permutations.out done %cat permutations.out Tests: Passed Tests: Passed Tests: Passed Tests: Passed Tests: Passed Tests: Passed If you're developing in Linux, you can even use Valgrind to automatically detect many memory management and threading bugs, and profile your programs in detail.","title":"Testing the C program: Python scripting"},{"location":"signal_converters/","text":"Practical Class 1 - Signal Representation This practical class reviews some of the possible representations of a signal both in the time domain and in the frequency domain. All of the practical classes will take advantage of the Python programming language to study and model signal converters. The Jupyter Notebooks are a great way to segment the developed code, enabling an easier debugging and learning experience. The Jupyter Notebooks also enable the introduction of Markdown latex HTML notes in the middle of the code cells, offering a truly complete note-taking environment. import numpy as np import matplotlib.pyplot as plt import scienceplots plt.style.use(['science', 'notebook']) %matplotlib inline Signal Representation in the Time-Domain This section covers some nuances of the represenation of a signal (voltage/current/code) in the time-domain, throughout an independent axis representing time. Two main aspects of the representation of a signal are presented: 1- A signal can be decomposed on an infinite sum of fundamental trigonometric functions (sine and cosine), according to Fourier's Signal Theory; 2- The importance of using a differential signal chain is analysed to observe its impact on the overall distortion of the output signal. # define the number of points for the simulation # NOTE: This enables a better control of the simulation time and memmory resources Np = 1001 # define time base Fs = 100e3 Ts = 1/Fs tD = np.arange(0,Np)*Ts; # (0:Np-1) == np.arange(0,Np) tD # define the signals Amp1 = 1 f1 = 1e3 phase1 = 0 phase1_rad = np.deg2rad(phase1) x1 = Amp1*np.sin(2*np.pi*f1*tD + phase1_rad) x1 # visualize the signals fig, ax = plt.subplots(1,1, figsize = (10,4)) ax.plot(tD, x1, lw = 2, ls=\"-\", color='b', ms=3) ax.grid(True) ax.set_ylabel(\"Voltage (V)\") ax.set_xlabel(\"Time (s)\") ax.legend() plt.show() # changing the frequency of the signal # define the new signal Amp2 = 1 f2 = 0.5e3 phase2 = 0 phase2_rad = np.deg2rad(phase1) x2 = Amp2*np.sin(2*np.pi*f2*tD + phase1_rad) x2 # visualize the signals fig, ax = plt.subplots(1,1, figsize = (10,4)) ax.plot(tD, x2, lw = 2, ls=\"-\", color=\"r\", ms=3) ax.grid(True) ax.set_ylabel(\"Voltage (V)\") ax.set_xlabel(\"Time (s)\") ax.legend() plt.show() # observing 2 sinusoids in the same plot # second harmonic Amp2 = 0.5 f2 = 2e3 phase2_rad = np.deg2rad(0) x2 = Amp2*np.sin(2*np.pi*f2*tD + phase2_rad) # third harmonic Amp3 = 0.2 f3 = 3e3 phase3_rad = np.deg2rad(0) x3 = Amp3*np.sin(2*np.pi*f3*tD + phase3_rad) Visualize the signals and infer on the veracity of the Fourier Series representation of the signal - any signal can be represented as a sum of sinusoids! In this case, the sum of x1 with x3 can almost generate a digital signal denominated as a square wave. fig, ax = plt.subplots(3,1, figsize = (10,10)) ax[0].plot(tD, x1, lw = 2, ls=\"-\", color=\"b\", marker=\"None\", ms=3, label=\"x1\") ax[0].plot(tD, x2, lw = 2, ls=\"-\", color=\"g\", marker=\"None\", ms=3, label=\"x2\") ax[0].plot(tD, x3, lw = 2, ls=\"-\", color=\"r\", marker=\"None\", ms=3, label=\"x3\") ax[0].set_title(\"x1(t), x3(t)\") ax[0].legend(frameon=True, facecolor=\"pink\", edgecolor=\"none\") ax[0].grid(True) ax[0].set_ylabel(\"Voltage (V)\") ax[1].plot(tD, x1+x2, lw = 2, ls=\"-\", color=\"k\", marker=\"None\", ms=3) ax[1].set_title(\"x1(t) + x2(t)\") ax[1].grid(True) ax[1].set_ylabel(\"Voltage (V)\") ax[2].plot(tD, x1+x3, lw = 2, ls=\"-\", color=\"k\", marker=\"None\", ms=3) ax[2].set_title(\"x1(t) + x3(t)\") ax[2].grid(True) ax[2].set_ylabel(\"Voltage (V)\") ax[2].set_xlabel(\"Time (s)\") fig.tight_layout() plt.show() From the above signal representations, two conclusions can be made: The odd harmonics allow to preserve the area ratio of the positive wave and negative wave of the signal in relation to the average value.In other words, the odd harmonics allow the signal to preserve its symmetry. The same is not true for the even harmonics. The even harmonics do not ensure that the signal preserves its symmetry in relation to its average value. Any signal processing chain, or signal conversion chain should always be differential, in which the processed signals feature a phase of 180 \u00ba between each other. Differential signals enable the natural cancellation of the even harmonic components of the signal, significantly improving the linearity of the signal at the output of the signal processign chain. Demo: Given the signal: $$s(t) = a_1 sin(2\\pi f_1t + \\phi_1) + [a_2 sin(2\\pi f_1t + \\phi_2)]^2 + [a_3 *sin(2\\pi f_1t + \\phi_3)]^3$$ where: $f_2 = 2f_1$ and $f_3=3f_1$ The differential rendition of this signal would give us: $$s(t) - s(t+180\u00ba) = 2a_1 sin(2\\pi f_1t + \\phi_1) + \\frac{4a_3^2}{3} sin(2\\pi 3f_1t + \\phi_3) + s_{DC}$$ As it is possible to observe, the even harmonic components are cancelled, and thus the distortion is reduced. Signal Representation in the Frequency-Domain This section covers the representation of the signals defined in the previous section in the frequency domain. The signal representation defined by Fourier's series holds true in the frequency spectrum. A depiction of this is the representation of the sum of the x1, x2 and x3 signals in the frequency spectrum, featuring the resulting three dirac distributions. The frequencies of these distributions correspond to the fundamental, second and third harmonics of the signal resulting from the sum of the signals. # spectral analysis using fft - fast fourier transform yt = x1+x2+x3 yf = np.abs(np.fft.fftshift(np.fft.fft(yt) / Np)) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform fD = np.fft.fftshift(np.fft.fftfreq(Np, Ts)) # [Hz] # frequency axis power_yf = (yf*yf) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf_dB = 10 * np.log10(power_yf) # [dB] - convert the power spectrum to dB power_yf_dB yf2 = np.abs(np.fft.fftshift(np.fft.fft(x1) / Np)) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yf2 = (yf2*yf2) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf2_dB = 10 * np.log10(power_yf2) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig, ax = plt.subplots(2,1, figsize=(10,5)) f_scale = 1e3# frequency scale [Hz] p_scale = 1 # power scale in [dB] ax[0].stem( fD[fD>=0] / f_scale, power_yf_dB[fD>=0] / p_scale, bottom=np.min(power_yf_dB / p_scale), #use_line_collection=True, linefmt=\"b-\", markerfmt=\"none\", basefmt=\"r-\", ) ax[0].set_xlabel(\"Frequency (KHz)\") ax[0].set_ylabel(\"Power (dB)\") ax[0].set_title(\"Frequency spectrum of x1+x2+x3\") f_lim = 4e3/f_scale # limitting frequency ax[0].set_xlim([0, f_lim]) ax[0].set_ylim([-40, 0]) ax[1].plot( fD[fD>=0] / f_scale, power_yf2_dB[fD>=0] / p_scale, ls=\"-\", color=\"k\", marker=\"none\" ) ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_xlim([0, f_lim]) fig.tight_layout() As it is possible to observe, the plot of x1 in black (the second curve) gives us a spectral dirac that is not concentrated on a single frequency bin, and rather spreads throughout the frequency with decreasing power throughout the spectrum. One possible solution: Windows! The use of a window defining the simulation time window in which the spectrum of the signal will be analysed can significantly improve the spectral quality of the observed signal in the frequency spectrum. The following example uses a Blackman-Harris window, multiplying it to the signal in the time-domain. As such, the obtained signal's frequency spectrum features a much more perceptible definition of the central frequency of each signal's harmonic. The resulting computed spectral power of each harmonic appears to be lower than the spectrum obtained without the use of a window. This is a mere appearance, and it results from the fact that the Blackman-Harris window causes the power of each harmonic to be spread throughout 5 frequency bins (2 bins before, the central bin of the harmonic and 2 bins after). NOTE: Another solution (which is actually preferred) would be to use coherent sampling - ensuring the sampling frequency is simultaneously a prime number and a multiple of the input signal's frequency. Both solutions can also be used simultaneously. # applying a blackman harris window to # better observe the signal's spectrum from scipy import signal window = signal.windows.blackmanharris(Np) fig,ax = plt.subplots(1,figsize=(4,4)) ax.set_xlabel('Samples') ax.set_ylabel('Window Amplitude') plt.plot(window) # spectral analysis using fft - fast fourier transform ytbm = yt*signal.windows.blackmanharris(Np) yfbm = np.abs(np.fft.fftshift(np.fft.fft(ytbm) / Np)) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yfbm = (yfbm*yfbm) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yfbm_dB = 10 * np.log10(power_yfbm) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig, ax = plt.subplots(2,1, figsize=(10,5)) f_scale = 1e3# frequency scale [Hz] p_scale = 1 # power scale in [dB] ax[0].stem( fD[fD>=0] / f_scale, power_yf_dB[fD>=0] / p_scale, bottom=np.min(power_yf_dB / p_scale), #use_line_collection=True, linefmt=\"b-\", markerfmt=\"none\", basefmt=\"r-\", ) ax[0].set_xlabel(\"Frequency (KHz)\") ax[0].set_ylabel(\"Power (dB)\") ax[0].set_title(\"Frequency spectrum of x1+x2+x3\") f_lim = 4e3/f_scale # limitting frequency ax[0].set_xlim([0, f_lim]) ax[0].set_ylim([-40, 0]) ax[1].plot( fD[fD>=0] / f_scale, power_yf_dB[fD>=0] / p_scale, ls=\"-\", color=\"k\", marker=\"none\", ) ax[1].plot( fD[fD>=0] / f_scale, power_yfbm_dB[fD>=0] / p_scale, ls=\"-\", color=\"r\", marker=\"none\", ) ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_xlim([0, f_lim]) fig.tight_layout() Noise Sources and Representation To perform a more accurate simulation of the signal converters that are going to be studied in this course, a superposition of noise to the processed signal is inevitable and required. The process of quantizing an ideal signal without any supperposed noise will inevitably add a quantization error to the signal, as seen in the following equation. $$ s_Q(t) = s(t) + \\epsilon_Q(t) \\hspace{10pt} (1)$$ where $\\epsilon_Q(t)$ is the quantization error, $s_Q(t)$ is the quantized signal and $s(t)$ is the processed signal. However, in reality all analog signals are subject to some form of noise. If the processed signal features a given level of noise power superposed to it, and the signal converter/quantizer features an high-enough quantization precision, the quantization error can actually be well approximated by white noise, as seen in (2). White noise is present throughout all the spectrum of both the signal and the quantizing system. It features a constant power spectral density throughout the system's operation spectrum, and as such it is very easy to model through a uniform distribution. $$s_Q(t) = (x(t) + n(t)) + \\epsilon_Q(t) = x(t) + v_{NQ}(t) \\hspace{10pt} (2)$$ where $x(t)$ is the processed signal, $n(t)$ is the noise superposed to the processed signal and $v_{NQ}(t)$ is the quantization white noise approximated by the sum of $n(t)$ and $\\epsilon_Q(t)$. from numpy.random import normal, uniform # random numbers fitted into a normal or uniform distribution import seaborn as sns # to observe the noise signal's histogram # define the quantizer's main parameters nbits = 4 # number of bits vref = 0.9 # reference voltage [V] vlsb = vref / (2**nbits) # fundamental step votlage of the quantizer [V] # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = (vlsb**2)/12 # quantization noise variance [V] vqstddev = np.sqrt(vqvar) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = uniform(-vqstddev, vqstddev, Np) # quantization noise signal with a uniform dist (white noise)[V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np.abs(np.fft.fftshift(np.fft.fft(vq) / Np)) # [V] # voltage in the frequency axis pqf = (vqf*vqf) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np.log10(pqf) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig, ax = plt.subplots(3,1, figsize=(10,10)) ax[0].plot(tD, vq, ls=\"-\", color=\"k\", marker=\"none\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Voltage (V)\") ax[0].set_title(\"Quantization noise signal\") ax[1].plot( fD[fD>=0] / f_scale, pqf_dB[fD>=0] / p_scale, ls=\"-\", color=\"gray\", marker=\"none\") ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_title(\"Quantization noise signal's frequency spectrum\") sns.histplot(vq, ax=ax[2], color=\"gray\") ax[2].hlines( y=np.mean(np.histogram(vq, bins=10)[0]), xmin=-vqstddev, xmax=vqstddev, color=\"r\") ax[2].set_xlabel(\"Voltage (V)\") ax[2].set_ylabel(\"Count\") ax[2].set_title(\"Quantization noise signal's histogram\") ax[0].grid() ax[1].grid() ax[2].grid(False) fig.tight_layout() # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = (vlsb**2)/12 # quantization noise variance [V] vqstddev = np.sqrt(vqvar) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = normal(vqmean, vqstddev, Np) # gaussian noise signal with a normal dist [V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np.abs(np.fft.fftshift(np.fft.fft(vq) / Np)) # [V] # voltage in the frequency axis pqf = (vqf*vqf) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np.log10(pqf) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram #! OBSERVE A NOISE SIGNAL DEFINED USNG A NORMAL DISTRIBUTION fig, ax = plt.subplots(3,1, figsize=(10,10)) ax[0].plot(tD, vq, ls=\"-\", color=\"k\", marker=\"none\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Voltage (V)\") ax[0].set_title(\"Gaussian noise signal\") ax[1].plot( fD[fD>=0] / f_scale, pqf_dB[fD>=0] / p_scale, ls=\"-\", color=\"gray\", marker=\"none\") ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_title(\"Gaussian noise signal's frequency spectrum\") sns.histplot(vq, ax=ax[2], color=\"gray\", edgecolor=\"gray\", kde=True) #ax[2].vlines( # x=np.mean(vq), # ymin=0, ymax=np.mean(np.histogram(vq, bins=10)[0]), color=\"r\") ax[2].set_xlabel(\"Voltage (V)\") ax[2].set_ylabel(\"Count\") ax[2].set_title(\"Gaussian noise signal's histogram\") ax[0].grid() ax[1].grid() ax[2].grid(False) fig.tight_layout() # let us now superpose the noise signal to the x1 signal and observe # the resulting signal's frequency spectrum, histogram and time domain Amp1 = 0.2 # amplitude of the sine wave [V] x1 = Amp1*np.sin(2*np.pi*f1*tD + phase1_rad) # [V] - sine wave vq = uniform(-vqstddev, vqstddev, Np) # quantization noise signal with a uniform dist (white noise)[V] st = x1 + vq stf = np.abs(np.fft.fftshift(np.fft.fft(st) / Np)) # [V] # voltage in the frequency axis ptf = (stf*stf) # [V^2] - square the voltage spectrum to obtain the power spectrum ptf_dB = 10 * np.log10(ptf) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig, ax = plt.subplots(3,1, figsize=(10,10)) ax[0].plot(tD, st, ls=\"-\", color=\"k\", marker=\"none\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Voltage (V)\") ax[0].set_title(r\"Quantized signal - $s(t)$\") ax[1].plot( fD[fD>=0] / f_scale, ptf_dB[fD>=0] / p_scale, ls=\"-\", color=\"gray\", marker=\"none\") ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_title(\"Quantized signal's frequency spectrum\") sns.histplot(st, ax=ax[2], color=\"gray\", kde=True) ax[2].set_xlabel(\"Voltage (V)\") ax[2].set_ylabel(\"Count\") ax[2].set_title(\"Quantized signal's histogram\") ax[0].grid() ax[1].grid() ax[2].grid(False) fig.tight_layout() Practical Class 2 - Ideal ADC and DAC modelling The models of an ideal ADC and DAC biased with a Vref voltage and N bits of resolution are presented in this notebook. The covnersion functions of both converters were created using the lambda programming style. Using this style, the creator function for the ADC or DAC receives the 2 fundamental parameters defining these ideal electronic systems: Vref - The reference/biasing voltage of the converter; Nbits - the number of bits of the converter system (its digital resolution). The converter then returns a function that depending on its input will generate an output code or voltage, for the ADC or DAC, respectively. from functools import reduce import numpy as np import matplotlib.pyplot as plt import scienceplots plt.style.use(['science', 'notebook']) %matplotlib inline # define the function to convert a binary vector to decimal def bin2dec(x, width): \"\"\"Convert a numpy array from binary to decimal. IF the input is an array of binary arrays, the returned output is an array of the corresponding decimals in their corresponding indexes. Parameters: x: numpy array b: base of the number system \"\"\" x = np.array(x) if x.size == width: assert len(x) == width, \"The length of the vector must be equal to the number of bits\" return reduce(lambda x,b: 2*x + b, x) assert len(x[0]) == width, \"The length of the vector must be equal to the number of bits\" return np.array(np.array([reduce(lambda xval,b: 2*xval + b, xval) for xval in x])) def dec2bin(x, width): \"\"\"Convert a numpy array from decimal to binary If the input is an array of decimals, the returned binary arrays are the codes corresponding to each decimal in its corresponding index. Parameters: x: numpy array b: base of the number system \"\"\" x = np.array(x) if x.size == 1: return np.array([int(c) for c in np.binary_repr(x, width=width)]) return np.array([np.array([int(c) for c in np.binary_repr(subx, width=width)]) for subx in x]) # test x = np.array([1,0,1,1,0,1]) assert bin2dec(x,6) == 45 x = np.array([1,0,1]) assert bin2dec(x,3) == 5 Digital-to-Analog Converter Modelling This section presents the definition of the ideal model for the transfer function of a DAC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (1). There are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$V_{OUT}(D_{in}) = base_{10}{D_{in}}*V_{LSB}\\hspace{10 pt} (1)$$ where $D_{in}$ is the input binary word of the DAC, $V_{LSB}$ is the Least Significant Bit step voltage and $V_{OUT}$ is the output voltage of the DAC. # Modelling an ideal Digital to Analog Converter (DAC) vref = 5 # The biasing voltage of the DAC [V] n_bits = 3 # The resolution of the ideal DAC # define the ideal model of a DAC using lambda programming def ideal_dac(vref:float, n_bits:int): \"\"\"Define the transfer function of an ideal DAC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. Returns: function(Din): the lambda function defining the transfer function of the DAC \"\"\" vlsb = vref/(2**n_bits) # compute the fundamental step voltage between quantized levels return lambda x: bin2dec(x, n_bits)*vlsb # return the converter funtion # define the DAC's transfer function idac = ideal_dac(vref, n_bits) # define the array of decimal input codes # belonging to [0, 2^{n_bits}-1] x = np.arange(2**n_bits) print(x) # convert the input codes array # from decimal to binary using arrays of 1s and 0s x_bin = np.array([dec2bin(i, n_bits) for i in x]) # create the string representation of the binary words x_bin_str = [ \"\".join([str(num) for num in xv]) for xv in x_bin] print(x_bin) print(idac(x_bin[1])) # get the corresponding output voltages # of the DAC for each corresponding input code y = idac(x_bin) # plot the transfer function of the ideal DAC fig, ax = plt.subplots(2,1, figsize=(8,8)) ax[0].plot(x_bin_str, y, marker=\"o\", mfc=\"None\") # mfc == marker face color ax[0].set_xticklabels(x_bin_str, rotation=45) ax[0].set_yticks(y) ax[0].set_xlabel('Code') ax[0].set_ylabel('Voltage (V)') ax[0].set_title('Ideal DAC Transfer Function (Vout(Din))') ax[0].grid(True) ax[1].step(x_bin_str, y, marker=\"None\", color=\"k\", label=\"floor\", where=\"post\") # note that the step function of the DAC is always a post step! ax[1].set_xticklabels(x_bin_str, rotation=45) ax[1].set_yticks(y) ax[1].set_xlabel('Code') ax[1].set_ylabel('Voltage (V)') ax[1].grid(True) fig.tight_layout() [0 1 2 3 4 5 6 7] [[0 0 0] [0 0 1] [0 1 0] [0 1 1] [1 0 0] [1 0 1] [1 1 0] [1 1 1]] 0.625 /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:20: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[0].set_xticklabels(x_bin_str, rotation=45) /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:28: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[1].set_xticklabels(x_bin_str, rotation=45) Analog-to-Digital Converter Modelling This section presents the definition of the ideal model for the transfer function of a ADC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (2). Once again, there are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$D_{OUT}(V_{in}, f_{Round}) = base_2{f_{Round}(V_{in}/V_{LSB})} \\hspace{10 pt} (2)$$ where $V_{in}$ is the input voltage of the ADC, $V_{LSB}$ is the Least Significant Bit step voltage and $D_{OUT}$ is the output digital code of the ADC. $f_{Round}$ is the rounding function that the ADC implements in practice, and this function can be one of three possible solutions: a) round(.), rounding to the nearest decimal; b) ceil(.), rounding to the highest decimal; c) floor(.), rounding to the lowest decimal. In this case, equation (2) defines an ADC transfer function that returns the output code in the form of a binary digital word, to provide consistency with the presented code below. It is important to note that the the rounding function is parsed as an input to the ADC's transfer function for practical, low-code purposes. # modelling an ideal ADC vref = 5 # V n_bits = 3 # bits def ideal_adc(vref:float, nbits:int, roundf): \"\"\"Define the transfer function of an ideal ADC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. roundf (function): The rounding function to be used. Returns: function(Vin): the lambda function defining the transfer function of the ADC \"\"\" assert roundf in [np.round, np.ceil, np.floor], \"The round function must be numpy.floor, numpy.ceil or numpy.round\" vlsb = vref/(2**nbits) return lambda x: dec2bin(roundf(x/vlsb).astype(int), nbits) iadc = ideal_adc(vref, n_bits, np.round) iadc_ceil = ideal_adc(vref, n_bits, np.ceil) iadc_floor = ideal_adc(vref, n_bits, np.floor) print(iadc(np.array([0,1,2,3,4]))) x = np.arange(0, vref,vref/2**n_bits) y = iadc(x) y_str = [ \"\".join([str(num) for num in yv]) for yv in y] print(y_str) fig, ax = plt.subplots(2,1, figsize=(8,8)) ax[0].plot(x, y_str, marker=\"o\", color=\"k\", mfc=\"None\") ax[0].set_xticks(x) ax[0].set_xticklabels(x, rotation=45) ax[0].set_xlabel('Voltage (V)') ax[0].set_ylabel('Code') ax[1].step(x, y_str, marker=\"None\", color=\"k\", label=\"round\", where=\"mid\") y = iadc_ceil(x) y_str = [ \"\".join([str(num) for num in yv]) for yv in y] ax[1].step(x, y_str, marker=\"None\", color=\"r\", label=\"ceil\", where=\"post\") ax[1].set_xticks(x) ax[1].set_xticklabels(x, rotation=45) ax[1].set_xlabel('Voltage (V)') ax[1].set_ylabel('Code') y = iadc_floor(x) y_str = [ \"\".join([str(num) for num in yv]) for yv in y] ax[1].step(x, y_str, marker=\"None\", color=\"b\", label=\"floor\", where=\"pre\") ax[1].set_xticks(x) ax[1].set_xticklabels(x, rotation=45) ax[1].set_xlabel('Voltage (V)') ax[1].set_ylabel('Code') ax[0].set_xlim([0, vref]) ax[1].set_xlim([0, vref]) fig.tight_layout() ax[0].set_title(\"Dout(Vin)\") ax[0].grid(True) ax[1].grid(True) ax[1].legend() fig.tight_layout() [[0 0 0] [0 1 0] [0 1 1] [1 0 1] [1 1 0]] ['000', '001', '010', '011', '100', '101', '110', '111']","title":"Signal-Converters"},{"location":"signal_converters/#practical-class-1-signal-representation","text":"This practical class reviews some of the possible representations of a signal both in the time domain and in the frequency domain. All of the practical classes will take advantage of the Python programming language to study and model signal converters. The Jupyter Notebooks are a great way to segment the developed code, enabling an easier debugging and learning experience. The Jupyter Notebooks also enable the introduction of Markdown latex HTML notes in the middle of the code cells, offering a truly complete note-taking environment. import numpy as np import matplotlib.pyplot as plt import scienceplots plt.style.use(['science', 'notebook']) %matplotlib inline","title":"Practical Class 1 - Signal Representation"},{"location":"signal_converters/#signal-representation-in-the-time-domain","text":"This section covers some nuances of the represenation of a signal (voltage/current/code) in the time-domain, throughout an independent axis representing time. Two main aspects of the representation of a signal are presented: 1- A signal can be decomposed on an infinite sum of fundamental trigonometric functions (sine and cosine), according to Fourier's Signal Theory; 2- The importance of using a differential signal chain is analysed to observe its impact on the overall distortion of the output signal. # define the number of points for the simulation # NOTE: This enables a better control of the simulation time and memmory resources Np = 1001 # define time base Fs = 100e3 Ts = 1/Fs tD = np.arange(0,Np)*Ts; # (0:Np-1) == np.arange(0,Np) tD # define the signals Amp1 = 1 f1 = 1e3 phase1 = 0 phase1_rad = np.deg2rad(phase1) x1 = Amp1*np.sin(2*np.pi*f1*tD + phase1_rad) x1 # visualize the signals fig, ax = plt.subplots(1,1, figsize = (10,4)) ax.plot(tD, x1, lw = 2, ls=\"-\", color='b', ms=3) ax.grid(True) ax.set_ylabel(\"Voltage (V)\") ax.set_xlabel(\"Time (s)\") ax.legend() plt.show() # changing the frequency of the signal # define the new signal Amp2 = 1 f2 = 0.5e3 phase2 = 0 phase2_rad = np.deg2rad(phase1) x2 = Amp2*np.sin(2*np.pi*f2*tD + phase1_rad) x2 # visualize the signals fig, ax = plt.subplots(1,1, figsize = (10,4)) ax.plot(tD, x2, lw = 2, ls=\"-\", color=\"r\", ms=3) ax.grid(True) ax.set_ylabel(\"Voltage (V)\") ax.set_xlabel(\"Time (s)\") ax.legend() plt.show() # observing 2 sinusoids in the same plot # second harmonic Amp2 = 0.5 f2 = 2e3 phase2_rad = np.deg2rad(0) x2 = Amp2*np.sin(2*np.pi*f2*tD + phase2_rad) # third harmonic Amp3 = 0.2 f3 = 3e3 phase3_rad = np.deg2rad(0) x3 = Amp3*np.sin(2*np.pi*f3*tD + phase3_rad) Visualize the signals and infer on the veracity of the Fourier Series representation of the signal - any signal can be represented as a sum of sinusoids! In this case, the sum of x1 with x3 can almost generate a digital signal denominated as a square wave. fig, ax = plt.subplots(3,1, figsize = (10,10)) ax[0].plot(tD, x1, lw = 2, ls=\"-\", color=\"b\", marker=\"None\", ms=3, label=\"x1\") ax[0].plot(tD, x2, lw = 2, ls=\"-\", color=\"g\", marker=\"None\", ms=3, label=\"x2\") ax[0].plot(tD, x3, lw = 2, ls=\"-\", color=\"r\", marker=\"None\", ms=3, label=\"x3\") ax[0].set_title(\"x1(t), x3(t)\") ax[0].legend(frameon=True, facecolor=\"pink\", edgecolor=\"none\") ax[0].grid(True) ax[0].set_ylabel(\"Voltage (V)\") ax[1].plot(tD, x1+x2, lw = 2, ls=\"-\", color=\"k\", marker=\"None\", ms=3) ax[1].set_title(\"x1(t) + x2(t)\") ax[1].grid(True) ax[1].set_ylabel(\"Voltage (V)\") ax[2].plot(tD, x1+x3, lw = 2, ls=\"-\", color=\"k\", marker=\"None\", ms=3) ax[2].set_title(\"x1(t) + x3(t)\") ax[2].grid(True) ax[2].set_ylabel(\"Voltage (V)\") ax[2].set_xlabel(\"Time (s)\") fig.tight_layout() plt.show() From the above signal representations, two conclusions can be made: The odd harmonics allow to preserve the area ratio of the positive wave and negative wave of the signal in relation to the average value.In other words, the odd harmonics allow the signal to preserve its symmetry. The same is not true for the even harmonics. The even harmonics do not ensure that the signal preserves its symmetry in relation to its average value. Any signal processing chain, or signal conversion chain should always be differential, in which the processed signals feature a phase of 180 \u00ba between each other. Differential signals enable the natural cancellation of the even harmonic components of the signal, significantly improving the linearity of the signal at the output of the signal processign chain. Demo: Given the signal: $$s(t) = a_1 sin(2\\pi f_1t + \\phi_1) + [a_2 sin(2\\pi f_1t + \\phi_2)]^2 + [a_3 *sin(2\\pi f_1t + \\phi_3)]^3$$ where: $f_2 = 2f_1$ and $f_3=3f_1$ The differential rendition of this signal would give us: $$s(t) - s(t+180\u00ba) = 2a_1 sin(2\\pi f_1t + \\phi_1) + \\frac{4a_3^2}{3} sin(2\\pi 3f_1t + \\phi_3) + s_{DC}$$ As it is possible to observe, the even harmonic components are cancelled, and thus the distortion is reduced.","title":"Signal Representation in the Time-Domain"},{"location":"signal_converters/#signal-representation-in-the-frequency-domain","text":"This section covers the representation of the signals defined in the previous section in the frequency domain. The signal representation defined by Fourier's series holds true in the frequency spectrum. A depiction of this is the representation of the sum of the x1, x2 and x3 signals in the frequency spectrum, featuring the resulting three dirac distributions. The frequencies of these distributions correspond to the fundamental, second and third harmonics of the signal resulting from the sum of the signals. # spectral analysis using fft - fast fourier transform yt = x1+x2+x3 yf = np.abs(np.fft.fftshift(np.fft.fft(yt) / Np)) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform fD = np.fft.fftshift(np.fft.fftfreq(Np, Ts)) # [Hz] # frequency axis power_yf = (yf*yf) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf_dB = 10 * np.log10(power_yf) # [dB] - convert the power spectrum to dB power_yf_dB yf2 = np.abs(np.fft.fftshift(np.fft.fft(x1) / Np)) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yf2 = (yf2*yf2) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf2_dB = 10 * np.log10(power_yf2) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig, ax = plt.subplots(2,1, figsize=(10,5)) f_scale = 1e3# frequency scale [Hz] p_scale = 1 # power scale in [dB] ax[0].stem( fD[fD>=0] / f_scale, power_yf_dB[fD>=0] / p_scale, bottom=np.min(power_yf_dB / p_scale), #use_line_collection=True, linefmt=\"b-\", markerfmt=\"none\", basefmt=\"r-\", ) ax[0].set_xlabel(\"Frequency (KHz)\") ax[0].set_ylabel(\"Power (dB)\") ax[0].set_title(\"Frequency spectrum of x1+x2+x3\") f_lim = 4e3/f_scale # limitting frequency ax[0].set_xlim([0, f_lim]) ax[0].set_ylim([-40, 0]) ax[1].plot( fD[fD>=0] / f_scale, power_yf2_dB[fD>=0] / p_scale, ls=\"-\", color=\"k\", marker=\"none\" ) ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_xlim([0, f_lim]) fig.tight_layout() As it is possible to observe, the plot of x1 in black (the second curve) gives us a spectral dirac that is not concentrated on a single frequency bin, and rather spreads throughout the frequency with decreasing power throughout the spectrum.","title":"Signal Representation in the Frequency-Domain"},{"location":"signal_converters/#one-possible-solution-windows","text":"The use of a window defining the simulation time window in which the spectrum of the signal will be analysed can significantly improve the spectral quality of the observed signal in the frequency spectrum. The following example uses a Blackman-Harris window, multiplying it to the signal in the time-domain. As such, the obtained signal's frequency spectrum features a much more perceptible definition of the central frequency of each signal's harmonic. The resulting computed spectral power of each harmonic appears to be lower than the spectrum obtained without the use of a window. This is a mere appearance, and it results from the fact that the Blackman-Harris window causes the power of each harmonic to be spread throughout 5 frequency bins (2 bins before, the central bin of the harmonic and 2 bins after). NOTE: Another solution (which is actually preferred) would be to use coherent sampling - ensuring the sampling frequency is simultaneously a prime number and a multiple of the input signal's frequency. Both solutions can also be used simultaneously. # applying a blackman harris window to # better observe the signal's spectrum from scipy import signal window = signal.windows.blackmanharris(Np) fig,ax = plt.subplots(1,figsize=(4,4)) ax.set_xlabel('Samples') ax.set_ylabel('Window Amplitude') plt.plot(window) # spectral analysis using fft - fast fourier transform ytbm = yt*signal.windows.blackmanharris(Np) yfbm = np.abs(np.fft.fftshift(np.fft.fft(ytbm) / Np)) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yfbm = (yfbm*yfbm) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yfbm_dB = 10 * np.log10(power_yfbm) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig, ax = plt.subplots(2,1, figsize=(10,5)) f_scale = 1e3# frequency scale [Hz] p_scale = 1 # power scale in [dB] ax[0].stem( fD[fD>=0] / f_scale, power_yf_dB[fD>=0] / p_scale, bottom=np.min(power_yf_dB / p_scale), #use_line_collection=True, linefmt=\"b-\", markerfmt=\"none\", basefmt=\"r-\", ) ax[0].set_xlabel(\"Frequency (KHz)\") ax[0].set_ylabel(\"Power (dB)\") ax[0].set_title(\"Frequency spectrum of x1+x2+x3\") f_lim = 4e3/f_scale # limitting frequency ax[0].set_xlim([0, f_lim]) ax[0].set_ylim([-40, 0]) ax[1].plot( fD[fD>=0] / f_scale, power_yf_dB[fD>=0] / p_scale, ls=\"-\", color=\"k\", marker=\"none\", ) ax[1].plot( fD[fD>=0] / f_scale, power_yfbm_dB[fD>=0] / p_scale, ls=\"-\", color=\"r\", marker=\"none\", ) ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_xlim([0, f_lim]) fig.tight_layout()","title":"One possible solution: Windows!"},{"location":"signal_converters/#noise-sources-and-representation","text":"To perform a more accurate simulation of the signal converters that are going to be studied in this course, a superposition of noise to the processed signal is inevitable and required. The process of quantizing an ideal signal without any supperposed noise will inevitably add a quantization error to the signal, as seen in the following equation. $$ s_Q(t) = s(t) + \\epsilon_Q(t) \\hspace{10pt} (1)$$ where $\\epsilon_Q(t)$ is the quantization error, $s_Q(t)$ is the quantized signal and $s(t)$ is the processed signal. However, in reality all analog signals are subject to some form of noise. If the processed signal features a given level of noise power superposed to it, and the signal converter/quantizer features an high-enough quantization precision, the quantization error can actually be well approximated by white noise, as seen in (2). White noise is present throughout all the spectrum of both the signal and the quantizing system. It features a constant power spectral density throughout the system's operation spectrum, and as such it is very easy to model through a uniform distribution. $$s_Q(t) = (x(t) + n(t)) + \\epsilon_Q(t) = x(t) + v_{NQ}(t) \\hspace{10pt} (2)$$ where $x(t)$ is the processed signal, $n(t)$ is the noise superposed to the processed signal and $v_{NQ}(t)$ is the quantization white noise approximated by the sum of $n(t)$ and $\\epsilon_Q(t)$. from numpy.random import normal, uniform # random numbers fitted into a normal or uniform distribution import seaborn as sns # to observe the noise signal's histogram # define the quantizer's main parameters nbits = 4 # number of bits vref = 0.9 # reference voltage [V] vlsb = vref / (2**nbits) # fundamental step votlage of the quantizer [V] # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = (vlsb**2)/12 # quantization noise variance [V] vqstddev = np.sqrt(vqvar) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = uniform(-vqstddev, vqstddev, Np) # quantization noise signal with a uniform dist (white noise)[V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np.abs(np.fft.fftshift(np.fft.fft(vq) / Np)) # [V] # voltage in the frequency axis pqf = (vqf*vqf) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np.log10(pqf) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig, ax = plt.subplots(3,1, figsize=(10,10)) ax[0].plot(tD, vq, ls=\"-\", color=\"k\", marker=\"none\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Voltage (V)\") ax[0].set_title(\"Quantization noise signal\") ax[1].plot( fD[fD>=0] / f_scale, pqf_dB[fD>=0] / p_scale, ls=\"-\", color=\"gray\", marker=\"none\") ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_title(\"Quantization noise signal's frequency spectrum\") sns.histplot(vq, ax=ax[2], color=\"gray\") ax[2].hlines( y=np.mean(np.histogram(vq, bins=10)[0]), xmin=-vqstddev, xmax=vqstddev, color=\"r\") ax[2].set_xlabel(\"Voltage (V)\") ax[2].set_ylabel(\"Count\") ax[2].set_title(\"Quantization noise signal's histogram\") ax[0].grid() ax[1].grid() ax[2].grid(False) fig.tight_layout() # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = (vlsb**2)/12 # quantization noise variance [V] vqstddev = np.sqrt(vqvar) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = normal(vqmean, vqstddev, Np) # gaussian noise signal with a normal dist [V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np.abs(np.fft.fftshift(np.fft.fft(vq) / Np)) # [V] # voltage in the frequency axis pqf = (vqf*vqf) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np.log10(pqf) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram #! OBSERVE A NOISE SIGNAL DEFINED USNG A NORMAL DISTRIBUTION fig, ax = plt.subplots(3,1, figsize=(10,10)) ax[0].plot(tD, vq, ls=\"-\", color=\"k\", marker=\"none\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Voltage (V)\") ax[0].set_title(\"Gaussian noise signal\") ax[1].plot( fD[fD>=0] / f_scale, pqf_dB[fD>=0] / p_scale, ls=\"-\", color=\"gray\", marker=\"none\") ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_title(\"Gaussian noise signal's frequency spectrum\") sns.histplot(vq, ax=ax[2], color=\"gray\", edgecolor=\"gray\", kde=True) #ax[2].vlines( # x=np.mean(vq), # ymin=0, ymax=np.mean(np.histogram(vq, bins=10)[0]), color=\"r\") ax[2].set_xlabel(\"Voltage (V)\") ax[2].set_ylabel(\"Count\") ax[2].set_title(\"Gaussian noise signal's histogram\") ax[0].grid() ax[1].grid() ax[2].grid(False) fig.tight_layout() # let us now superpose the noise signal to the x1 signal and observe # the resulting signal's frequency spectrum, histogram and time domain Amp1 = 0.2 # amplitude of the sine wave [V] x1 = Amp1*np.sin(2*np.pi*f1*tD + phase1_rad) # [V] - sine wave vq = uniform(-vqstddev, vqstddev, Np) # quantization noise signal with a uniform dist (white noise)[V] st = x1 + vq stf = np.abs(np.fft.fftshift(np.fft.fft(st) / Np)) # [V] # voltage in the frequency axis ptf = (stf*stf) # [V^2] - square the voltage spectrum to obtain the power spectrum ptf_dB = 10 * np.log10(ptf) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig, ax = plt.subplots(3,1, figsize=(10,10)) ax[0].plot(tD, st, ls=\"-\", color=\"k\", marker=\"none\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Voltage (V)\") ax[0].set_title(r\"Quantized signal - $s(t)$\") ax[1].plot( fD[fD>=0] / f_scale, ptf_dB[fD>=0] / p_scale, ls=\"-\", color=\"gray\", marker=\"none\") ax[1].set_xlabel(\"Frequency (KHz)\") ax[1].set_ylabel(\"Power (dB)\") ax[1].set_title(\"Quantized signal's frequency spectrum\") sns.histplot(st, ax=ax[2], color=\"gray\", kde=True) ax[2].set_xlabel(\"Voltage (V)\") ax[2].set_ylabel(\"Count\") ax[2].set_title(\"Quantized signal's histogram\") ax[0].grid() ax[1].grid() ax[2].grid(False) fig.tight_layout()","title":"Noise Sources and Representation"},{"location":"signal_converters/#practical-class-2-ideal-adc-and-dac-modelling","text":"The models of an ideal ADC and DAC biased with a Vref voltage and N bits of resolution are presented in this notebook. The covnersion functions of both converters were created using the lambda programming style. Using this style, the creator function for the ADC or DAC receives the 2 fundamental parameters defining these ideal electronic systems: Vref - The reference/biasing voltage of the converter; Nbits - the number of bits of the converter system (its digital resolution). The converter then returns a function that depending on its input will generate an output code or voltage, for the ADC or DAC, respectively. from functools import reduce import numpy as np import matplotlib.pyplot as plt import scienceplots plt.style.use(['science', 'notebook']) %matplotlib inline # define the function to convert a binary vector to decimal def bin2dec(x, width): \"\"\"Convert a numpy array from binary to decimal. IF the input is an array of binary arrays, the returned output is an array of the corresponding decimals in their corresponding indexes. Parameters: x: numpy array b: base of the number system \"\"\" x = np.array(x) if x.size == width: assert len(x) == width, \"The length of the vector must be equal to the number of bits\" return reduce(lambda x,b: 2*x + b, x) assert len(x[0]) == width, \"The length of the vector must be equal to the number of bits\" return np.array(np.array([reduce(lambda xval,b: 2*xval + b, xval) for xval in x])) def dec2bin(x, width): \"\"\"Convert a numpy array from decimal to binary If the input is an array of decimals, the returned binary arrays are the codes corresponding to each decimal in its corresponding index. Parameters: x: numpy array b: base of the number system \"\"\" x = np.array(x) if x.size == 1: return np.array([int(c) for c in np.binary_repr(x, width=width)]) return np.array([np.array([int(c) for c in np.binary_repr(subx, width=width)]) for subx in x]) # test x = np.array([1,0,1,1,0,1]) assert bin2dec(x,6) == 45 x = np.array([1,0,1]) assert bin2dec(x,3) == 5","title":"Practical Class 2 - Ideal ADC and DAC modelling"},{"location":"signal_converters/#digital-to-analog-converter-modelling","text":"This section presents the definition of the ideal model for the transfer function of a DAC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (1). There are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$V_{OUT}(D_{in}) = base_{10}{D_{in}}*V_{LSB}\\hspace{10 pt} (1)$$ where $D_{in}$ is the input binary word of the DAC, $V_{LSB}$ is the Least Significant Bit step voltage and $V_{OUT}$ is the output voltage of the DAC. # Modelling an ideal Digital to Analog Converter (DAC) vref = 5 # The biasing voltage of the DAC [V] n_bits = 3 # The resolution of the ideal DAC # define the ideal model of a DAC using lambda programming def ideal_dac(vref:float, n_bits:int): \"\"\"Define the transfer function of an ideal DAC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. Returns: function(Din): the lambda function defining the transfer function of the DAC \"\"\" vlsb = vref/(2**n_bits) # compute the fundamental step voltage between quantized levels return lambda x: bin2dec(x, n_bits)*vlsb # return the converter funtion # define the DAC's transfer function idac = ideal_dac(vref, n_bits) # define the array of decimal input codes # belonging to [0, 2^{n_bits}-1] x = np.arange(2**n_bits) print(x) # convert the input codes array # from decimal to binary using arrays of 1s and 0s x_bin = np.array([dec2bin(i, n_bits) for i in x]) # create the string representation of the binary words x_bin_str = [ \"\".join([str(num) for num in xv]) for xv in x_bin] print(x_bin) print(idac(x_bin[1])) # get the corresponding output voltages # of the DAC for each corresponding input code y = idac(x_bin) # plot the transfer function of the ideal DAC fig, ax = plt.subplots(2,1, figsize=(8,8)) ax[0].plot(x_bin_str, y, marker=\"o\", mfc=\"None\") # mfc == marker face color ax[0].set_xticklabels(x_bin_str, rotation=45) ax[0].set_yticks(y) ax[0].set_xlabel('Code') ax[0].set_ylabel('Voltage (V)') ax[0].set_title('Ideal DAC Transfer Function (Vout(Din))') ax[0].grid(True) ax[1].step(x_bin_str, y, marker=\"None\", color=\"k\", label=\"floor\", where=\"post\") # note that the step function of the DAC is always a post step! ax[1].set_xticklabels(x_bin_str, rotation=45) ax[1].set_yticks(y) ax[1].set_xlabel('Code') ax[1].set_ylabel('Voltage (V)') ax[1].grid(True) fig.tight_layout() [0 1 2 3 4 5 6 7] [[0 0 0] [0 0 1] [0 1 0] [0 1 1] [1 0 0] [1 0 1] [1 1 0] [1 1 1]] 0.625 /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:20: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[0].set_xticklabels(x_bin_str, rotation=45) /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:28: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[1].set_xticklabels(x_bin_str, rotation=45)","title":"Digital-to-Analog Converter Modelling"},{"location":"signal_converters/#analog-to-digital-converter-modelling","text":"This section presents the definition of the ideal model for the transfer function of a ADC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (2). Once again, there are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$D_{OUT}(V_{in}, f_{Round}) = base_2{f_{Round}(V_{in}/V_{LSB})} \\hspace{10 pt} (2)$$ where $V_{in}$ is the input voltage of the ADC, $V_{LSB}$ is the Least Significant Bit step voltage and $D_{OUT}$ is the output digital code of the ADC. $f_{Round}$ is the rounding function that the ADC implements in practice, and this function can be one of three possible solutions: a) round(.), rounding to the nearest decimal; b) ceil(.), rounding to the highest decimal; c) floor(.), rounding to the lowest decimal. In this case, equation (2) defines an ADC transfer function that returns the output code in the form of a binary digital word, to provide consistency with the presented code below. It is important to note that the the rounding function is parsed as an input to the ADC's transfer function for practical, low-code purposes. # modelling an ideal ADC vref = 5 # V n_bits = 3 # bits def ideal_adc(vref:float, nbits:int, roundf): \"\"\"Define the transfer function of an ideal ADC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. roundf (function): The rounding function to be used. Returns: function(Vin): the lambda function defining the transfer function of the ADC \"\"\" assert roundf in [np.round, np.ceil, np.floor], \"The round function must be numpy.floor, numpy.ceil or numpy.round\" vlsb = vref/(2**nbits) return lambda x: dec2bin(roundf(x/vlsb).astype(int), nbits) iadc = ideal_adc(vref, n_bits, np.round) iadc_ceil = ideal_adc(vref, n_bits, np.ceil) iadc_floor = ideal_adc(vref, n_bits, np.floor) print(iadc(np.array([0,1,2,3,4]))) x = np.arange(0, vref,vref/2**n_bits) y = iadc(x) y_str = [ \"\".join([str(num) for num in yv]) for yv in y] print(y_str) fig, ax = plt.subplots(2,1, figsize=(8,8)) ax[0].plot(x, y_str, marker=\"o\", color=\"k\", mfc=\"None\") ax[0].set_xticks(x) ax[0].set_xticklabels(x, rotation=45) ax[0].set_xlabel('Voltage (V)') ax[0].set_ylabel('Code') ax[1].step(x, y_str, marker=\"None\", color=\"k\", label=\"round\", where=\"mid\") y = iadc_ceil(x) y_str = [ \"\".join([str(num) for num in yv]) for yv in y] ax[1].step(x, y_str, marker=\"None\", color=\"r\", label=\"ceil\", where=\"post\") ax[1].set_xticks(x) ax[1].set_xticklabels(x, rotation=45) ax[1].set_xlabel('Voltage (V)') ax[1].set_ylabel('Code') y = iadc_floor(x) y_str = [ \"\".join([str(num) for num in yv]) for yv in y] ax[1].step(x, y_str, marker=\"None\", color=\"b\", label=\"floor\", where=\"pre\") ax[1].set_xticks(x) ax[1].set_xticklabels(x, rotation=45) ax[1].set_xlabel('Voltage (V)') ax[1].set_ylabel('Code') ax[0].set_xlim([0, vref]) ax[1].set_xlim([0, vref]) fig.tight_layout() ax[0].set_title(\"Dout(Vin)\") ax[0].grid(True) ax[1].grid(True) ax[1].legend() fig.tight_layout() [[0 0 0] [0 1 0] [0 1 1] [1 0 1] [1 1 0]] ['000', '001', '010', '011', '100', '101', '110', '111']","title":"Analog-to-Digital Converter Modelling"}]}