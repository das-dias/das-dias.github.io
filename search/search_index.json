{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Analog / Mixed-Signal IC Engineer PhD candidate at NOVA-UNL / TU Delft Welcome. This is a personal website built on top of MkDocs . Hi! My name is Diogo Andr\u00e9. I'm currently pursuing a PhD in Nanoelectronics under a mixed-scholarship at NOVA University of Lisbon, School of Science and Technology (Monte da Caparica, Portugal), and TU Delft, Bioelectronics Group (Delft, The Netherlands). I'm specialising in Analog / Mixed-Signal IC Design, focusing on Analog Front-Ends and Quantizer ASIC Interfaces for Ultrasound Imaging Transducer Arrays. I am also a big fan of using C-lang and Python to develop my own tools for automatic layout design and custom extractors for parasitic passive lumped elements and crosstalk between signal lines. Feel free to contact me! \ud83d\udcc2 Personal Info \ud83d\udcc5 Nov 19, 1998 \ud83c\udfe0 R. Bento Gon\u00e7alves 68, 2835-674 Barreiro, Portugal E-mail: \ud83d\udce7 das.dias@campus.fct.unl.pt \ud83d\udce7 ddias@tudelft.nl \ud83d\udd17 Google Scholar \ud83d\udd17 GitHub \ud83d\udd17 LinkedIn \ud83c\udf93 Education MSc. in Electrical and Computers Engineering NOVA University of Lisbon (Sep 2019 - Dec 2021) Grade: 17/20 BSc. in Electrical and Computers Engineering NOVA University of Lisbon (Sep 2016 - Jul 2019) Grade: 17/20 \ud83c\udfe2 Experience CMOS Process Development Kits (PDKs) 28 nm (HPC+) TSMC PDK , 130 nm UMC PDK PhD Candidate (ASICs For Ultrasound Image-Guided Vagus Nerve Stimulation) NOVA University of Lisbon, Delft University of Technology (May 2022 - Ongoing) Nyquist Data-Rate Converters Course (Teaching Assistant) Delft University of Technology (Feb - May 2024) Erasmus+ Traineeship Student Delft University of Technology (Feb - Jun 2021) - Master Thesis Dissertation Electronics II Course (Teaching Assistant) NOVA University of Lisbon (Sep - Dec 2019) \ud83d\udcda Research A PVT-Robust Open-loop Gm-Ratio\u00d7 16 Gain Residue Amplifier for> 1 GS/s Pipelined ADCs CTS, LASI, NOVA University of Lisbon (Dec 2023) - IEEE ISCAS \u201924 Publication A Parasitic Resistance Extraction Tool Leveraged by Image Processing PDEEC, NOVA University of Lisbon (Dec 2021) - IEEE ISCAS \u201922 Publication Preliminary Assessment of an Ultrasonic Level Sensor for the Calorimetric Measurement of AC Losses in Superconducting Devices CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - YEF-ECE \u201922 Publication Ultrasound-based Cryogenic Monitoring System for Superconducting Systems CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - EUCAS \u201921 Publication \ud83d\udee0\ufe0f Technical Skills & Tools Cadence - Analog / Mixed-Signal Base-Band & RF IC Design Cadence / KLayout / Python - IC Layout Design Xillinx ISE - Digital IC Design, Verilog MATLAB, Python, C, Verilog MS Office, Git, LaTeX (Mac) OSX, Linux(Ubuntu/CentOS), Windows \ud83c\udfc6 Certifications Artificial Intelligence Course Samsung Innovation Campus at NOVA University of Lisbon (Jun - Sep 2021) \ud83d\udd2c Projects novaad Open-Source Software Contribution - A Python tool for Look-up Table (LUT)-based Gm/Id Analog IC design. gdsfactory/gplugins/spice Open-Source Software Contribution - A Python library for converting between YAML Markup language and SPICE schematic netlist description language. This tool explores the use of modern computer Markup language YAML to represent schematic netlists, allowing for integrated photonic and electronic schematics to co-exist and relate to each other in a single human-readable file. YAML has also readily available Serializer/Deserializer parsers for most common programming languages (C++, C, Python, Ruby, Go, ...). Important Note: both the base source code for the gdsfactory/gplugins/spice and gdsfactory/gplugins/vlsir tools were initially aggregated into a personal repository of mine - parcirc . gdsfactory/gplugins/vlsir Open-Source Software Contribution - A Python library for converting between Klayout's DB Netlist format and other electrical schematic file formats (SPICE, Spectre, Xyce) - More about the tool at: gdsfactory.github.io/gplugins/notebooks/vlsir_netlist This work is supported and inspired by Dan Fritchman's VLSIR Tools work, linking the way PDK information is represented in the older, closed-source custom filesystem formats to new, open-source, supported and maintained file and binary formats that allow for a greater information compression and inter-programming language data-structure sharing and interpretation through the use of Google's Protobuf data interface protocol. I highly encourage you to read more about Dan Fritchman's work . Master Thesis Dissertation NOVA University of Lisbon & Delft University of Technology (Sep 2020 - Dec 2021) - \"On the Use of Image Processing for 3D Parasitic Resistance Networks Extraction in Integrated Circuits\" - Grade: 19/20 Zero-IF FSK RF Receiver Analog Front-End NOVA University of Lisbon (Sep - Dec 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology 120 dB Gain, Low-Voltage (0.9 V supply) Operational Transconductance Amplifier NOVA University of Lisbon (Sep - Nov 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology 66 dB Gain, 100 MHz GBW Fully-Differential Hybrid Telescopic-Folded Cascode Amplifier NOVA University of Lisbon (Nov - Dec 2019) - Designed in 0.13\u00b5m (MM/RF) UMC technology \ud83c\udf0d Languages Portuguese: \u25cb \u25cb \u25cb \u25cb \u25cb English: \u25cb \u25cb \u25cb \u25cb \u25cb Spanish: \u25cb \u25cb \u25cb Dutch: \u25cb \u25cb \ud83c\udfad Extra-Curricular Activities Pedagogical Committee Representative NOVA University of Lisbon (Nov 2019 - Jul 2021) - Electrical and Computers Engineering Department Volunteer Work \u2013 Refood Telheiras, Lisbon Sep - Dec 2019 - Redistribution of food waste \ud83c\udfa8 Hobbies Reading and watching documentaries about History Electric Bass Guitar Half-Marathon Running Contributing to open-source EDA-CAD software","title":"Home"},{"location":"#personal-info","text":"\ud83d\udcc5 Nov 19, 1998 \ud83c\udfe0 R. Bento Gon\u00e7alves 68, 2835-674 Barreiro, Portugal E-mail: \ud83d\udce7 das.dias@campus.fct.unl.pt \ud83d\udce7 ddias@tudelft.nl \ud83d\udd17 Google Scholar \ud83d\udd17 GitHub \ud83d\udd17 LinkedIn","title":"\ud83d\udcc2 Personal Info"},{"location":"#education","text":"","title":"\ud83c\udf93 Education"},{"location":"#msc-in-electrical-and-computers-engineering","text":"NOVA University of Lisbon (Sep 2019 - Dec 2021) Grade: 17/20","title":"MSc. in Electrical and Computers Engineering"},{"location":"#bsc-in-electrical-and-computers-engineering","text":"NOVA University of Lisbon (Sep 2016 - Jul 2019) Grade: 17/20","title":"BSc. in Electrical and Computers Engineering"},{"location":"#experience","text":"","title":"\ud83c\udfe2 Experience"},{"location":"#cmos-process-development-kits-pdks","text":"28 nm (HPC+) TSMC PDK , 130 nm UMC PDK","title":"CMOS Process Development Kits (PDKs)"},{"location":"#phd-candidate-asics-for-ultrasound-image-guided-vagus-nerve-stimulation","text":"NOVA University of Lisbon, Delft University of Technology (May 2022 - Ongoing)","title":"PhD Candidate (ASICs For Ultrasound Image-Guided Vagus Nerve Stimulation)"},{"location":"#nyquist-data-rate-converters-course-teaching-assistant","text":"Delft University of Technology (Feb - May 2024)","title":"Nyquist Data-Rate Converters Course (Teaching Assistant)"},{"location":"#erasmus-traineeship-student","text":"Delft University of Technology (Feb - Jun 2021) - Master Thesis Dissertation","title":"Erasmus+ Traineeship Student"},{"location":"#electronics-ii-course-teaching-assistant","text":"NOVA University of Lisbon (Sep - Dec 2019)","title":"Electronics II Course (Teaching Assistant)"},{"location":"#research","text":"","title":"\ud83d\udcda Research"},{"location":"#a-pvt-robust-open-loop-gm-ratio-16-gain-residue-amplifier-for-1-gss-pipelined-adcs","text":"CTS, LASI, NOVA University of Lisbon (Dec 2023) - IEEE ISCAS \u201924 Publication","title":"A PVT-Robust Open-loop Gm-Ratio\u00d7 16 Gain Residue Amplifier for&gt; 1 GS/s Pipelined ADCs"},{"location":"#a-parasitic-resistance-extraction-tool-leveraged-by-image-processing","text":"PDEEC, NOVA University of Lisbon (Dec 2021) - IEEE ISCAS \u201922 Publication","title":"A Parasitic Resistance Extraction Tool Leveraged by Image Processing"},{"location":"#preliminary-assessment-of-an-ultrasonic-level-sensor-for-the-calorimetric-measurement-of-ac-losses-in-superconducting-devices","text":"CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - YEF-ECE \u201922 Publication","title":"Preliminary Assessment of an Ultrasonic Level Sensor for the Calorimetric Measurement of AC Losses in Superconducting Devices"},{"location":"#ultrasound-based-cryogenic-monitoring-system-for-superconducting-systems","text":"CTS, NOVA University of Lisbon (Sep 2020 - Sep 2021) - EUCAS \u201921 Publication","title":"Ultrasound-based Cryogenic Monitoring System for Superconducting Systems"},{"location":"#technical-skills-tools","text":"Cadence - Analog / Mixed-Signal Base-Band & RF IC Design Cadence / KLayout / Python - IC Layout Design Xillinx ISE - Digital IC Design, Verilog MATLAB, Python, C, Verilog MS Office, Git, LaTeX (Mac) OSX, Linux(Ubuntu/CentOS), Windows","title":"\ud83d\udee0\ufe0f Technical Skills &amp; Tools"},{"location":"#certifications","text":"","title":"\ud83c\udfc6 Certifications"},{"location":"#artificial-intelligence-course","text":"Samsung Innovation Campus at NOVA University of Lisbon (Jun - Sep 2021)","title":"Artificial Intelligence Course"},{"location":"#projects","text":"","title":"\ud83d\udd2c Projects"},{"location":"#novaad","text":"Open-Source Software Contribution - A Python tool for Look-up Table (LUT)-based Gm/Id Analog IC design.","title":"novaad"},{"location":"#gdsfactorygpluginsspice","text":"Open-Source Software Contribution - A Python library for converting between YAML Markup language and SPICE schematic netlist description language. This tool explores the use of modern computer Markup language YAML to represent schematic netlists, allowing for integrated photonic and electronic schematics to co-exist and relate to each other in a single human-readable file. YAML has also readily available Serializer/Deserializer parsers for most common programming languages (C++, C, Python, Ruby, Go, ...). Important Note: both the base source code for the gdsfactory/gplugins/spice and gdsfactory/gplugins/vlsir tools were initially aggregated into a personal repository of mine - parcirc .","title":"gdsfactory/gplugins/spice"},{"location":"#gdsfactorygpluginsvlsir","text":"Open-Source Software Contribution - A Python library for converting between Klayout's DB Netlist format and other electrical schematic file formats (SPICE, Spectre, Xyce) - More about the tool at: gdsfactory.github.io/gplugins/notebooks/vlsir_netlist This work is supported and inspired by Dan Fritchman's VLSIR Tools work, linking the way PDK information is represented in the older, closed-source custom filesystem formats to new, open-source, supported and maintained file and binary formats that allow for a greater information compression and inter-programming language data-structure sharing and interpretation through the use of Google's Protobuf data interface protocol. I highly encourage you to read more about Dan Fritchman's work .","title":"gdsfactory/gplugins/vlsir"},{"location":"#master-thesis-dissertation","text":"NOVA University of Lisbon & Delft University of Technology (Sep 2020 - Dec 2021) - \"On the Use of Image Processing for 3D Parasitic Resistance Networks Extraction in Integrated Circuits\" - Grade: 19/20","title":"Master Thesis Dissertation"},{"location":"#zero-if-fsk-rf-receiver-analog-front-end","text":"NOVA University of Lisbon (Sep - Dec 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology","title":"Zero-IF FSK RF Receiver Analog Front-End"},{"location":"#120-db-gain-low-voltage-09-v-supply-operational-transconductance-amplifier","text":"NOVA University of Lisbon (Sep - Nov 2020) - Designed in 0.13\u00b5m (MM/RF) UMC technology","title":"120 dB Gain, Low-Voltage (0.9 V supply) Operational Transconductance Amplifier"},{"location":"#66-db-gain-100-mhz-gbw-fully-differential-hybrid-telescopic-folded-cascode-amplifier","text":"NOVA University of Lisbon (Nov - Dec 2019) - Designed in 0.13\u00b5m (MM/RF) UMC technology","title":"66 dB Gain, 100 MHz GBW Fully-Differential Hybrid Telescopic-Folded Cascode Amplifier"},{"location":"#languages","text":"Portuguese: \u25cb \u25cb \u25cb \u25cb \u25cb English: \u25cb \u25cb \u25cb \u25cb \u25cb Spanish: \u25cb \u25cb \u25cb Dutch: \u25cb \u25cb","title":"\ud83c\udf0d Languages"},{"location":"#extra-curricular-activities","text":"","title":"\ud83c\udfad Extra-Curricular Activities"},{"location":"#pedagogical-committee-representative","text":"NOVA University of Lisbon (Nov 2019 - Jul 2021) - Electrical and Computers Engineering Department","title":"Pedagogical Committee Representative"},{"location":"#volunteer-work-refood-telheiras-lisbon","text":"Sep - Dec 2019 - Redistribution of food waste","title":"Volunteer Work \u2013 Refood Telheiras, Lisbon"},{"location":"#hobbies","text":"Reading and watching documentaries about History Electric Bass Guitar Half-Marathon Running Contributing to open-source EDA-CAD software","title":"\ud83c\udfa8 Hobbies"},{"location":"computational_electromagnetics/","text":"Coming soon...","title":"Computational Electromagnetics"},{"location":"computational_electromagnetics/#coming-soon","text":"","title":"Coming soon..."},{"location":"misc/","text":"This is a collection of interesting tools, sandboxes and projects I end up doing when I want to learn new things about programming (and more specifically scientific-programming), IC Design how EDA tools for IC design work and can be innovated. Hope you find something that you would like to try for yourself! Programming in C-lang with Jupyter Notebooks Introduction: Hello World! Start by writting your C-lang file: %% file hello_world . c #include <stdio.h> #include <stdlib.h> int main ( int argc , char ** argv ) { printf ( \"Hello World from C in Jupyter!\" ); exit ( 0 ); } Overwriting hello_world.c Now, compile your C code. %%bash gcc --version Apple clang version 15.0.0 (clang-1500.3.9.4) Target: arm64-apple-darwin23.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Compiling the code with the: - -W or --Wall flag is useful, enabling a wide variety of usefull warnings - -Werror treats critical warnings as errors, to make your code bulletproof once debugged. %%bash gcc ./hello_world.c -g -Werror -o hello_world Now, we can finally execute our C code from Jupyter. %%bash ./hello_world Hello World from C in Jupyter! Testing the C program: Python scripting We can now take advantage of having a documentation system with shell and Python scripting capabilities to quickly develop input testing files to run multiple test cases against the C program. This effectively automates the unit testing of the C program. from itertools import permutations inputs = permutations ([ 3 , '+' , 43 ]) with open ( 'permutations.in' , 'w' ) as testfile : def str_from_perm ( perm : list ) -> str : s = str ( perm ) s = s . replace ( '(' , '' ); s = s . replace ( ')' , '' ); s = s . replace ( \"'\" , '' ); s = s . replace ( ',' , '' ) return s + ' \\n ' [ testfile . write ( str_from_perm ( perm )) for perm in inputs ] % cat permutations . in 3 + 43 3 43 + + 3 43 + 43 3 43 3 + 43 + 3 %% file permutations . c #include <stdlib.h> #include <stdio.h> #include <string.h> #include <assert.h> char * expected_tokens [] = { \"3\" , \"A\" , \"+\" , \"6\" , \"43\" , NULL }; int arg_in_expected_tokens ( char * arg , char ** tokens ){ int found_token_chars = 0 ; for ( char ** it_token = tokens ; * it_token != NULL ; it_token ++ ){ if ( ! strcmp ( arg , * it_token )) return 1 ; } printf ( \"Assertion Failed: %s not in [\" , arg ); for ( char ** it_token = tokens ; * it_token != NULL ; ++ it_token ) printf ( \" %s , \" , * it_token ); printf ( \"] \\n \" ); return 0 ; } int main ( int argc , char ** argv ) { assert ( argc > 1 ); for ( int i = 1 ; i < argc ; i ++ ) assert ( arg_in_expected_tokens ( argv [ i ], expected_tokens )); printf ( \"Tests: Passed \\n \" ); exit ( 0 ); } Overwriting permutations.c %%bash gcc ./permutations.c -g -Werror -o permutations Finally, use bash shell scripting to input all inputs, line by line, to the C programm, so that each test is verified. %%bash echo \"\" > permutations.out cat permutations.in | while read line do ./permutations $line >> permutations.out done % cat permutations . out Tests : Passed Tests : Passed Tests : Passed Tests : Passed Tests : Passed Tests : Passed If you're developing in Linux, you can even use Valgrind to automatically detect many memory management and threading bugs, and profile your programs in detail.","title":"Miscellaneous"},{"location":"misc/#programming-in-c-lang-with-jupyter-notebooks","text":"","title":"Programming in C-lang with Jupyter Notebooks"},{"location":"misc/#introduction-hello-world","text":"Start by writting your C-lang file: %% file hello_world . c #include <stdio.h> #include <stdlib.h> int main ( int argc , char ** argv ) { printf ( \"Hello World from C in Jupyter!\" ); exit ( 0 ); } Overwriting hello_world.c Now, compile your C code. %%bash gcc --version Apple clang version 15.0.0 (clang-1500.3.9.4) Target: arm64-apple-darwin23.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin Compiling the code with the: - -W or --Wall flag is useful, enabling a wide variety of usefull warnings - -Werror treats critical warnings as errors, to make your code bulletproof once debugged. %%bash gcc ./hello_world.c -g -Werror -o hello_world Now, we can finally execute our C code from Jupyter. %%bash ./hello_world Hello World from C in Jupyter!","title":"Introduction: Hello World!"},{"location":"misc/#testing-the-c-program-python-scripting","text":"We can now take advantage of having a documentation system with shell and Python scripting capabilities to quickly develop input testing files to run multiple test cases against the C program. This effectively automates the unit testing of the C program. from itertools import permutations inputs = permutations ([ 3 , '+' , 43 ]) with open ( 'permutations.in' , 'w' ) as testfile : def str_from_perm ( perm : list ) -> str : s = str ( perm ) s = s . replace ( '(' , '' ); s = s . replace ( ')' , '' ); s = s . replace ( \"'\" , '' ); s = s . replace ( ',' , '' ) return s + ' \\n ' [ testfile . write ( str_from_perm ( perm )) for perm in inputs ] % cat permutations . in 3 + 43 3 43 + + 3 43 + 43 3 43 3 + 43 + 3 %% file permutations . c #include <stdlib.h> #include <stdio.h> #include <string.h> #include <assert.h> char * expected_tokens [] = { \"3\" , \"A\" , \"+\" , \"6\" , \"43\" , NULL }; int arg_in_expected_tokens ( char * arg , char ** tokens ){ int found_token_chars = 0 ; for ( char ** it_token = tokens ; * it_token != NULL ; it_token ++ ){ if ( ! strcmp ( arg , * it_token )) return 1 ; } printf ( \"Assertion Failed: %s not in [\" , arg ); for ( char ** it_token = tokens ; * it_token != NULL ; ++ it_token ) printf ( \" %s , \" , * it_token ); printf ( \"] \\n \" ); return 0 ; } int main ( int argc , char ** argv ) { assert ( argc > 1 ); for ( int i = 1 ; i < argc ; i ++ ) assert ( arg_in_expected_tokens ( argv [ i ], expected_tokens )); printf ( \"Tests: Passed \\n \" ); exit ( 0 ); } Overwriting permutations.c %%bash gcc ./permutations.c -g -Werror -o permutations Finally, use bash shell scripting to input all inputs, line by line, to the C programm, so that each test is verified. %%bash echo \"\" > permutations.out cat permutations.in | while read line do ./permutations $line >> permutations.out done % cat permutations . out Tests : Passed Tests : Passed Tests : Passed Tests : Passed Tests : Passed Tests : Passed If you're developing in Linux, you can even use Valgrind to automatically detect many memory management and threading bugs, and profile your programs in detail.","title":"Testing the C program: Python scripting"},{"location":"signal_converters/","text":"Signal Representation This practical class reviews some of the possible representations of a signal both in the time domain and in the frequency domain. All of the practical classes will take advantage of the Python programming language to study and model signal converters. The Jupyter Notebooks are a great way to segment the developed code, enabling an easier debugging and learning experience. The Jupyter Notebooks also enable the introduction of Markdown latex HTML notes in the middle of the code cells, offering a truly complete note-taking environment. import numpy as np import matplotlib.pyplot as plt import scienceplots plt . style . use ([ 'science' , 'notebook' ]) % matplotlib inline Signal Representation in the Time-Domain This section covers some nuances of the represenation of a signal (voltage/current/code) in the time-domain, throughout an independent axis representing time. Two main aspects of the representation of a signal are presented: 1- A signal can be decomposed on an infinite sum of fundamental trigonometric functions (sine and cosine), according to Fourier's Signal Theory; 2- The importance of using a differential signal chain is analysed to observe its impact on the overall distortion of the output signal. # define the number of points for the simulation # NOTE: This enables a better control of the simulation time and memmory resources Np = 1001 # define time base Fs = 100e3 Ts = 1 / Fs tD = np . arange ( 0 , Np ) * Ts ; # (0:Np-1) == np.arange(0,Np) tD # define the signals Amp1 = 1 f1 = 1e3 phase1 = 0 phase1_rad = np . deg2rad ( phase1 ) x1 = Amp1 * np . sin ( 2 * np . pi * f1 * tD + phase1_rad ) x1 # visualize the signals fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 4 )) ax . plot ( tD , x1 , lw = 2 , ls = \"-\" , color = 'b' , ms = 3 ) ax . grid ( True ) ax . set_ylabel ( \"Voltage (V)\" ) ax . set_xlabel ( \"Time (s)\" ) ax . legend () plt . show () # changing the frequency of the signal # define the new signal Amp2 = 1 f2 = 0.5e3 phase2 = 0 phase2_rad = np . deg2rad ( phase1 ) x2 = Amp2 * np . sin ( 2 * np . pi * f2 * tD + phase1_rad ) x2 # visualize the signals fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 4 )) ax . plot ( tD , x2 , lw = 2 , ls = \"-\" , color = \"r\" , ms = 3 ) ax . grid ( True ) ax . set_ylabel ( \"Voltage (V)\" ) ax . set_xlabel ( \"Time (s)\" ) ax . legend () plt . show () # observing 2 sinusoids in the same plot # second harmonic Amp2 = 0.5 f2 = 2e3 phase2_rad = np . deg2rad ( 0 ) x2 = Amp2 * np . sin ( 2 * np . pi * f2 * tD + phase2_rad ) # third harmonic Amp3 = 0.2 f3 = 3e3 phase3_rad = np . deg2rad ( 0 ) x3 = Amp3 * np . sin ( 2 * np . pi * f3 * tD + phase3_rad ) Visualize the signals and infer on the veracity of the Fourier Series representation of the signal - any signal can be represented as a sum of sinusoids! In this case, the sum of x1 with x3 can almost generate a digital signal denominated as a square wave. fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , x1 , lw = 2 , ls = \"-\" , color = \"b\" , marker = \"None\" , ms = 3 , label = \"x1\" ) ax [ 0 ] . plot ( tD , x2 , lw = 2 , ls = \"-\" , color = \"g\" , marker = \"None\" , ms = 3 , label = \"x2\" ) ax [ 0 ] . plot ( tD , x3 , lw = 2 , ls = \"-\" , color = \"r\" , marker = \"None\" , ms = 3 , label = \"x3\" ) ax [ 0 ] . set_title ( \"x1(t), x3(t)\" ) ax [ 0 ] . legend ( frameon = True , facecolor = \"pink\" , edgecolor = \"none\" ) ax [ 0 ] . grid ( True ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 1 ] . plot ( tD , x1 + x2 , lw = 2 , ls = \"-\" , color = \"k\" , marker = \"None\" , ms = 3 ) ax [ 1 ] . set_title ( \"x1(t) + x2(t)\" ) ax [ 1 ] . grid ( True ) ax [ 1 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 2 ] . plot ( tD , x1 + x3 , lw = 2 , ls = \"-\" , color = \"k\" , marker = \"None\" , ms = 3 ) ax [ 2 ] . set_title ( \"x1(t) + x3(t)\" ) ax [ 2 ] . grid ( True ) ax [ 2 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 2 ] . set_xlabel ( \"Time (s)\" ) fig . tight_layout () plt . show () From the above signal representations, two conclusions can be made: The odd harmonics allow to preserve the area ratio of the positive wave and negative wave of the signal in relation to the average value.In other words, the odd harmonics allow the signal to preserve its symmetry. The same is not true for the even harmonics. The even harmonics do not ensure that the signal preserves its symmetry in relation to its average value. Any signal processing chain, or signal conversion chain should always be differential, in which the processed signals feature a phase of 180 \u00ba between each other. Differential signals enable the natural cancellation of the even harmonic components of the signal, significantly improving the linearity of the signal at the output of the signal processign chain. Demo: Given the signal: $$ s(t) = a_1 sin(2\\pi f_1t + \\phi_1 ) + (a_2 sin(2\\pi f_1t + \\phi_2 ))^2 + (a_3 *sin(2\\pi f_1t + \\phi_3 ))^3 $$ where: $f_2 = 2f_1$ and $f_3=3f_1$ The differential rendition of this signal would give us: $$ s(t) - s(t+180\u00ba) = 2a_1 sin(2\\pi f_1t + \\phi_1) + \\frac{4a_3^2}{3} sin(2\\pi 3f_1t + \\phi_3) + s_{DC} $$ As it is possible to observe, the even harmonic components are cancelled, and thus the distortion is reduced. Signal Representation in the Frequency-Domain This section covers the representation of the signals defined in the previous section in the frequency domain. The signal representation defined by Fourier's series holds true in the frequency spectrum. A depiction of this is the representation of the sum of the x1, x2 and x3 signals in the frequency spectrum, featuring the resulting three dirac distributions. The frequencies of these distributions correspond to the fundamental, second and third harmonics of the signal resulting from the sum of the signals. # spectral analysis using fft - fast fourier transform yt = x1 + x2 + x3 yf = np . abs ( np . fft . fftshift ( np . fft . fft ( yt ) / Np )) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform fD = np . fft . fftshift ( np . fft . fftfreq ( Np , Ts )) # [Hz] # frequency axis power_yf = ( yf * yf ) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf_dB = 10 * np . log10 ( power_yf ) # [dB] - convert the power spectrum to dB power_yf_dB yf2 = np . abs ( np . fft . fftshift ( np . fft . fft ( x1 ) / Np )) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yf2 = ( yf2 * yf2 ) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf2_dB = 10 * np . log10 ( power_yf2 ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) f_scale = 1e3 # frequency scale [Hz] p_scale = 1 # power scale in [dB] ax [ 0 ] . stem ( fD [ fD >= 0 ] / f_scale , power_yf_dB [ fD >= 0 ] / p_scale , bottom = np . min ( power_yf_dB / p_scale ), #use_line_collection=True, linefmt = \"b-\" , markerfmt = \"none\" , basefmt = \"r-\" , ) ax [ 0 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 0 ] . set_ylabel ( \"Power (dB)\" ) ax [ 0 ] . set_title ( \"Frequency spectrum of x1+x2+x3\" ) f_lim = 4e3 / f_scale # limitting frequency ax [ 0 ] . set_xlim ([ 0 , f_lim ]) ax [ 0 ] . set_ylim ([ - 40 , 0 ]) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , power_yf2_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_xlim ([ 0 , f_lim ]) fig . tight_layout () As it is possible to observe, the plot of x1 in black (the second curve) gives us a spectral dirac that is not concentrated on a single frequency bin, and rather spreads throughout the frequency with decreasing power throughout the spectrum. One possible solution: Windows! The use of a window defining the simulation time window in which the spectrum of the signal will be analysed can significantly improve the spectral quality of the observed signal in the frequency spectrum. The following example uses a Blackman-Harris window, multiplying it to the signal in the time-domain. As such, the obtained signal's frequency spectrum features a much more perceptible definition of the central frequency of each signal's harmonic. The resulting computed spectral power of each harmonic appears to be lower than the spectrum obtained without the use of a window. This is a mere appearance, and it results from the fact that the Blackman-Harris window causes the power of each harmonic to be spread throughout 5 frequency bins (2 bins before, the central bin of the harmonic and 2 bins after). NOTE: Another solution (which is actually preferred) would be to use coherent sampling - ensuring the sampling frequency is simultaneously a prime number and a multiple of the input signal's frequency. Both solutions can also be used simultaneously. # applying a blackman harris window to # better observe the signal's spectrum from scipy import signal window = signal . windows . blackmanharris ( Np ) fig , ax = plt . subplots ( 1 , figsize = ( 4 , 4 )) ax . set_xlabel ( 'Samples' ) ax . set_ylabel ( 'Window Amplitude' ) plt . plot ( window ) # spectral analysis using fft - fast fourier transform ytbm = yt * signal . windows . blackmanharris ( Np ) yfbm = np . abs ( np . fft . fftshift ( np . fft . fft ( ytbm ) / Np )) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yfbm = ( yfbm * yfbm ) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yfbm_dB = 10 * np . log10 ( power_yfbm ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) f_scale = 1e3 # frequency scale [Hz] p_scale = 1 # power scale in [dB] ax [ 0 ] . stem ( fD [ fD >= 0 ] / f_scale , power_yf_dB [ fD >= 0 ] / p_scale , bottom = np . min ( power_yf_dB / p_scale ), #use_line_collection=True, linefmt = \"b-\" , markerfmt = \"none\" , basefmt = \"r-\" , ) ax [ 0 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 0 ] . set_ylabel ( \"Power (dB)\" ) ax [ 0 ] . set_title ( \"Frequency spectrum of x1+x2+x3\" ) f_lim = 4e3 / f_scale # limitting frequency ax [ 0 ] . set_xlim ([ 0 , f_lim ]) ax [ 0 ] . set_ylim ([ - 40 , 0 ]) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , power_yf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"k\" , marker = \"none\" , ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , power_yfbm_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"r\" , marker = \"none\" , ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_xlim ([ 0 , f_lim ]) fig . tight_layout () Noise Sources and Representation To perform a more accurate simulation of the signal converters that are going to be studied in this course, a superposition of noise to the processed signal is inevitable and required. The process of quantizing an ideal signal without any supperposed noise will inevitably add a quantization error to the signal, as seen in the following equation. $$ s_Q(t) = s(t) + \\epsilon_Q(t) \\hspace{10pt} (1) $$ where $\\epsilon_Q(t)$ is the quantization error, $s_Q(t)$ is the quantized signal and $s(t)$ is the processed signal. However, in reality all analog signals are subject to some form of noise. If the processed signal features a given level of noise power superposed to it, and the signal converter/quantizer features an high-enough quantization precision, the quantization error can actually be well approximated by white noise, as seen in (2). White noise is present throughout all the spectrum of both the signal and the quantizing system. It features a constant power spectral density throughout the system's operation spectrum, and as such it is very easy to model through a uniform distribution. $$ s_Q(t) = (x(t) + n(t)) + \\epsilon_Q(t) = x(t) + v_{NQ}(t) \\hspace{10pt} (2) $$ where $x(t)$ is the processed signal, $n(t)$ is the noise superposed to the processed signal and $v_{NQ}(t)$ is the quantization white noise approximated by the sum of $n(t)$ and $\\epsilon_Q(t)$. from numpy.random import normal , uniform # random numbers fitted into a normal or uniform distribution import seaborn as sns # to observe the noise signal's histogram # define the quantizer's main parameters nbits = 4 # number of bits vref = 0.9 # reference voltage [V] vlsb = vref / ( 2 ** nbits ) # fundamental step votlage of the quantizer [V] # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = ( vlsb ** 2 ) / 12 # quantization noise variance [V] vqstddev = np . sqrt ( vqvar ) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = uniform ( - vqstddev , vqstddev , Np ) # quantization noise signal with a uniform dist (white noise)[V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np . abs ( np . fft . fftshift ( np . fft . fft ( vq ) / Np )) # [V] # voltage in the frequency axis pqf = ( vqf * vqf ) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np . log10 ( pqf ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , vq , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 0 ] . set_xlabel ( \"Time (s)\" ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 0 ] . set_title ( \"Quantization noise signal\" ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , pqf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"gray\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_title ( \"Quantization noise signal's frequency spectrum\" ) sns . histplot ( vq , ax = ax [ 2 ], color = \"gray\" ) ax [ 2 ] . hlines ( y = np . mean ( np . histogram ( vq , bins = 10 )[ 0 ]), xmin =- vqstddev , xmax = vqstddev , color = \"r\" ) ax [ 2 ] . set_xlabel ( \"Voltage (V)\" ) ax [ 2 ] . set_ylabel ( \"Count\" ) ax [ 2 ] . set_title ( \"Quantization noise signal's histogram\" ) ax [ 0 ] . grid () ax [ 1 ] . grid () ax [ 2 ] . grid ( False ) fig . tight_layout () # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = ( vlsb ** 2 ) / 12 # quantization noise variance [V] vqstddev = np . sqrt ( vqvar ) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = normal ( vqmean , vqstddev , Np ) # gaussian noise signal with a normal dist [V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np . abs ( np . fft . fftshift ( np . fft . fft ( vq ) / Np )) # [V] # voltage in the frequency axis pqf = ( vqf * vqf ) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np . log10 ( pqf ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram #! OBSERVE A NOISE SIGNAL DEFINED USNG A NORMAL DISTRIBUTION fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , vq , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 0 ] . set_xlabel ( \"Time (s)\" ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 0 ] . set_title ( \"Gaussian noise signal\" ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , pqf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"gray\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_title ( \"Gaussian noise signal's frequency spectrum\" ) sns . histplot ( vq , ax = ax [ 2 ], color = \"gray\" , edgecolor = \"gray\" , kde = True ) #ax[2].vlines( # x=np.mean(vq), # ymin=0, ymax=np.mean(np.histogram(vq, bins=10)[0]), color=\"r\") ax [ 2 ] . set_xlabel ( \"Voltage (V)\" ) ax [ 2 ] . set_ylabel ( \"Count\" ) ax [ 2 ] . set_title ( \"Gaussian noise signal's histogram\" ) ax [ 0 ] . grid () ax [ 1 ] . grid () ax [ 2 ] . grid ( False ) fig . tight_layout () # let us now superpose the noise signal to the x1 signal and observe # the resulting signal's frequency spectrum, histogram and time domain Amp1 = 0.2 # amplitude of the sine wave [V] x1 = Amp1 * np . sin ( 2 * np . pi * f1 * tD + phase1_rad ) # [V] - sine wave vq = uniform ( - vqstddev , vqstddev , Np ) # quantization noise signal with a uniform dist (white noise)[V] st = x1 + vq stf = np . abs ( np . fft . fftshift ( np . fft . fft ( st ) / Np )) # [V] # voltage in the frequency axis ptf = ( stf * stf ) # [V^2] - square the voltage spectrum to obtain the power spectrum ptf_dB = 10 * np . log10 ( ptf ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , st , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 0 ] . set_xlabel ( \"Time (s)\" ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 0 ] . set_title ( r \"Quantized signal - $s(t)$\" ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , ptf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"gray\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_title ( \"Quantized signal's frequency spectrum\" ) sns . histplot ( st , ax = ax [ 2 ], color = \"gray\" , kde = True ) ax [ 2 ] . set_xlabel ( \"Voltage (V)\" ) ax [ 2 ] . set_ylabel ( \"Count\" ) ax [ 2 ] . set_title ( \"Quantized signal's histogram\" ) ax [ 0 ] . grid () ax [ 1 ] . grid () ax [ 2 ] . grid ( False ) fig . tight_layout () Ideal ADC and DAC modelling The models of an ideal ADC and DAC biased with a Vref voltage and N bits of resolution are presented in this notebook. The covnersion functions of both converters were created using the lambda programming style. Using this style, the creator function for the ADC or DAC receives the 2 fundamental parameters defining these ideal electronic systems: Vref - The reference/biasing voltage of the converter; Nbits - the number of bits of the converter system (its digital resolution). The converter then returns a function that depending on its input will generate an output code or voltage, for the ADC or DAC, respectively. from functools import reduce import numpy as np import matplotlib.pyplot as plt import scienceplots plt . style . use ([ 'science' , 'notebook' ]) % matplotlib inline # define the function to convert a binary vector to decimal def bin2dec ( x , width ): \"\"\"Convert a numpy array from binary to decimal. IF the input is an array of binary arrays, the returned output is an array of the corresponding decimals in their corresponding indexes. Parameters: x: numpy array b: base of the number system \"\"\" x = np . array ( x ) if x . size == width : assert len ( x ) == width , \"The length of the vector must be equal to the number of bits\" return reduce ( lambda x , b : 2 * x + b , x ) assert len ( x [ 0 ]) == width , \"The length of the vector must be equal to the number of bits\" return np . array ( np . array ([ reduce ( lambda xval , b : 2 * xval + b , xval ) for xval in x ])) def dec2bin ( x , width ): \"\"\"Convert a numpy array from decimal to binary If the input is an array of decimals, the returned binary arrays are the codes corresponding to each decimal in its corresponding index. Parameters: x: numpy array b: base of the number system \"\"\" x = np . array ( x ) if x . size == 1 : return np . array ([ int ( c ) for c in np . binary_repr ( x , width = width )]) return np . array ([ np . array ([ int ( c ) for c in np . binary_repr ( subx , width = width )]) for subx in x ]) # test x = np . array ([ 1 , 0 , 1 , 1 , 0 , 1 ]) assert bin2dec ( x , 6 ) == 45 x = np . array ([ 1 , 0 , 1 ]) assert bin2dec ( x , 3 ) == 5 Digital-to-Analog Converter Modelling This section presents the definition of the ideal model for the transfer function of a DAC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (1). There are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$ V_{OUT}(D_{in}) = base_{10}{D_{in}}*V_{LSB}\\hspace{10 pt} (1) $$ where $D_{in}$ is the input binary word of the DAC, $V_{LSB}$ is the Least Significant Bit step voltage and $V_{OUT}$ is the output voltage of the DAC. # Modelling an ideal Digital to Analog Converter (DAC) vref = 5 # The biasing voltage of the DAC [V] n_bits = 3 # The resolution of the ideal DAC # define the ideal model of a DAC using lambda programming def ideal_dac ( vref : float , n_bits : int ): \"\"\"Define the transfer function of an ideal DAC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. Returns: function(Din): the lambda function defining the transfer function of the DAC \"\"\" vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels return lambda x : bin2dec ( x , n_bits ) * vlsb # return the converter funtion # define the DAC's transfer function idac = ideal_dac ( vref , n_bits ) # define the array of decimal input codes # belonging to [0, 2^{n_bits}-1] x = np . arange ( 2 ** n_bits ) print ( x ) # convert the input codes array # from decimal to binary using arrays of 1s and 0s x_bin = np . array ([ dec2bin ( i , n_bits ) for i in x ]) # create the string representation of the binary words x_bin_str = [ \"\" . join ([ str ( num ) for num in xv ]) for xv in x_bin ] print ( x_bin ) print ( idac ( x_bin [ 1 ])) # get the corresponding output voltages # of the DAC for each corresponding input code y = idac ( x_bin ) # plot the transfer function of the ideal DAC fig , ax = plt . subplots ( 2 , 1 , figsize = ( 8 , 8 )) ax [ 0 ] . plot ( x_bin_str , y , marker = \"o\" , mfc = \"None\" ) # mfc == marker face color ax [ 0 ] . set_xticklabels ( x_bin_str , rotation = 45 ) ax [ 0 ] . set_yticks ( y ) ax [ 0 ] . set_xlabel ( 'Code' ) ax [ 0 ] . set_ylabel ( 'Voltage (V)' ) ax [ 0 ] . set_title ( 'Ideal DAC Transfer Function (Vout(Din))' ) ax [ 0 ] . grid ( True ) ax [ 1 ] . step ( x_bin_str , y , marker = \"None\" , color = \"k\" , label = \"floor\" , where = \"post\" ) # note that the step function of the DAC is always a post step! ax [ 1 ] . set_xticklabels ( x_bin_str , rotation = 45 ) ax [ 1 ] . set_yticks ( y ) ax [ 1 ] . set_xlabel ( 'Code' ) ax [ 1 ] . set_ylabel ( 'Voltage (V)' ) ax [ 1 ] . grid ( True ) fig . tight_layout () [0 1 2 3 4 5 6 7] [[0 0 0] [0 0 1] [0 1 0] [0 1 1] [1 0 0] [1 0 1] [1 1 0] [1 1 1]] 0.625 /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:20: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[0].set_xticklabels(x_bin_str, rotation = 45) /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:28: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[1].set_xticklabels(x_bin_str, rotation = 45) Analog-to-Digital Converter Modelling This section presents the definition of the ideal model for the transfer function of a ADC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (2). Once again, there are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$ D_{OUT}(V_{in}, f_{Round}) = base_2{f_{Round}(V_{in}/V_{LSB})} \\hspace{10 pt} (2) $$ where $V_{in}$ is the input voltage of the ADC, $V_{LSB}$ is the Least Significant Bit step voltage and $D_{OUT}$ is the output digital code of the ADC. $f_{Round}$ is the rounding function that the ADC implements in practice, and this function can be one of three possible solutions: a) round(.), rounding to the nearest decimal; b) ceil(.), rounding to the highest decimal; c) floor(.), rounding to the lowest decimal. In this case, equation (2) defines an ADC transfer function that returns the output code in the form of a binary digital word, to provide consistency with the presented code below. It is important to note that the the rounding function is parsed as an input to the ADC's transfer function for practical, low-code purposes. # modelling an ideal ADC vref = 5 # V n_bits = 3 # bits def ideal_adc ( vref : float , nbits : int , roundf ): \"\"\"Define the transfer function of an ideal ADC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. roundf (function): The rounding function to be used. Returns: function(Vin): the lambda function defining the transfer function of the ADC \"\"\" assert roundf in [ np . round , np . ceil , np . floor ], \"The round function must be numpy.floor, numpy.ceil or numpy.round\" vlsb = vref / ( 2 ** nbits ) return lambda x : dec2bin ( roundf ( x / vlsb ) . astype ( int ), nbits ) iadc = ideal_adc ( vref , n_bits , np . round ) iadc_ceil = ideal_adc ( vref , n_bits , np . ceil ) iadc_floor = ideal_adc ( vref , n_bits , np . floor ) print ( iadc ( np . array ([ 0 , 1 , 2 , 3 , 4 ]))) x = np . arange ( 0 , vref , vref / 2 ** n_bits ) y = iadc ( x ) y_str = [ \"\" . join ([ str ( num ) for num in yv ]) for yv in y ] print ( y_str ) fig , ax = plt . subplots ( 2 , 1 , figsize = ( 8 , 8 )) ax [ 0 ] . plot ( x , y_str , marker = \"o\" , color = \"k\" , mfc = \"None\" ) ax [ 0 ] . set_xticks ( x ) ax [ 0 ] . set_xticklabels ( x , rotation = 45 ) ax [ 0 ] . set_xlabel ( 'Voltage (V)' ) ax [ 0 ] . set_ylabel ( 'Code' ) ax [ 1 ] . step ( x , y_str , marker = \"None\" , color = \"k\" , label = \"round\" , where = \"mid\" ) y = iadc_ceil ( x ) y_str = [ \"\" . join ([ str ( num ) for num in yv ]) for yv in y ] ax [ 1 ] . step ( x , y_str , marker = \"None\" , color = \"r\" , label = \"ceil\" , where = \"post\" ) ax [ 1 ] . set_xticks ( x ) ax [ 1 ] . set_xticklabels ( x , rotation = 45 ) ax [ 1 ] . set_xlabel ( 'Voltage (V)' ) ax [ 1 ] . set_ylabel ( 'Code' ) y = iadc_floor ( x ) y_str = [ \"\" . join ([ str ( num ) for num in yv ]) for yv in y ] ax [ 1 ] . step ( x , y_str , marker = \"None\" , color = \"b\" , label = \"floor\" , where = \"pre\" ) ax [ 1 ] . set_xticks ( x ) ax [ 1 ] . set_xticklabels ( x , rotation = 45 ) ax [ 1 ] . set_xlabel ( 'Voltage (V)' ) ax [ 1 ] . set_ylabel ( 'Code' ) ax [ 0 ] . set_xlim ([ 0 , vref ]) ax [ 1 ] . set_xlim ([ 0 , vref ]) fig . tight_layout () ax [ 0 ] . set_title ( \"Dout(Vin)\" ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) ax [ 1 ] . legend () fig . tight_layout () [[0 0 0] [0 1 0] [0 1 1] [1 0 1] [1 1 0]] ['000', '001', '010', '011', '100', '101', '110', '111'] Linear and Non-linear Errors in DACs and ADCs The introduction of quantization noise in the ADC or DAC introduces errors associated with the quantization step size defining the true characteristic of the ADC or DAC transfer function. This notebook presents the modelling and study of the two main types of errors in converters: linear and non-linear. # mathematical computing import numpy as np from scipy import signal # to generate the noise signal import seaborn as sns # to observe the noise signal's histogram from numpy.random import uniform , normal # random numbers fitted into a uniform distribution # plotting import matplotlib.pyplot as plt # import the models and utilities functions from utils import ideal_dac , ideal_adc , nonideal_adc , dec2bin , bin2dec import scienceplots plt . style . use ([ 'science' , 'notebook' ]) DAC Errors Modelling DAC Linear Errors This section presents the modelling of the linear errors that arise when modelling the transfer function of a DAC. These errors relate to a deviation of the real transfer function of the DAC towards the ideal DAC's transfer function, in which each step size is exactly the same height! # define the DAC vref = 1.0 # define the reference voltage [V] n_bits = 5 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels # define an ideal DAC to compare the results idac = ideal_dac ( vref , n_bits ) # define a DAC with offset error voff = 0.05 dac_off = lambda x : idac ( x ) + voff # define a DAC with end of scale error # note that the end of scale error # is actually directly related to # the gain error of the DAC gain_err = - 0.1 target_gain = 1.0 + gain_err dac_eos = lambda x : idac ( x ) * target_gain # define a DAC with offset and end of scale error # to measure the true DAC gain error dac_off_eos = lambda x : idac ( x ) * target_gain + voff # define the input codes of the 3 DACs din = np . arange ( 2 ** n_bits ) # convert the decimals to input binary words dinb = dec2bin ( din , n_bits ) # create the string representation of the input codes dinb_str = [ \"\" . join ([ str ( num ) for num in xv ]) for xv in dinb ] # compute the output voltages of the 3 DACs vout = idac ( dinb ) vout_off = dac_off ( dinb ) vout_eos = dac_eos ( dinb ) vout_off_eos = dac_off_eos ( dinb ) To accurately measure the linear error of DACs it is only necessary to observe the initial and final points of the transfer function. From these points three measurements can be performed: Offset Error, represented in Eq.(1) End of Scale Error, represented in Eq.(2) Gain Error, represented in Eq.(3) The Gain Error of the DAC is directly related to both the End of Scale and Offset Errors of the DAC and is derived from them. The errors are measured in LSB units. $$ \\epsilon_{OFF} = \\frac{V_{OUT}'[T_0] - V_{OUT}[T_0]}{V_{LSB}} \\hspace{4 pt} [LSB] \\hspace{10 pt} (1) $$ $$ \\epsilon_{EOS} = \\frac{V_{OUT}'[T_{2^N - 1}] - V_{OUT}[T_{2^N - 1}]}{V_{LSB}} \\hspace{4 pt} [LSB] \\hspace{10 pt} (2) $$ $$ GER_{[\\%]} = \\left(\\frac{V_{OUT}'[T_{2^N - 1}] - V_{OUT}'[T_{0}]}{V_{OUT}[T_{2^N - 1}] - V_{OUT}[T_{0}]} - 1\\right)\\times100 \\hspace{10 pt} (3) $$ where $V_{OUT}[T_i]$ and $V_{OUT}'[T_i]$ is the output voltage of the ideal DAC and real DAC at the $i^{th}$ transition, respectively. # measure the DAC errors eoff = ( vout_off_eos [ 0 ] - vout [ 0 ]) / vlsb eeos = ( vout_off_eos [ 2 ** n_bits - 1 ] - vout [ 2 ** n_bits - 1 ]) / vlsb ger_pct = (( vout_off_eos [ 2 ** n_bits - 1 ] - vout_off_eos [ 0 ]) / ( vout [ 2 ** n_bits - 1 ] - vout [ 0 ]) - 1 ) * 100 print ( \"The offset error is {:.2f} LSB\" . format ( eoff )) print ( \"The end of scale error is {:.2f} LSB\" . format ( eeos )) print ( \"The gain error is {:.2f} %\" . format ( ger_pct )) The offset error is 1 . 60 LSB The end of scale error is - 1 . 50 LSB The gain error is - 10 . 00 % # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 8 )) ax . plot ( din , vout , label = \"Ideal DAC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax . step ( din , vout_off , where = \"post\" , label = \"DAC w/ offset error\" ) ax . step ( din , vout_eos , where = \"post\" , label = \"DAC w/ end of scale error\" ) ax . step ( din , vout_off_eos , where = \"post\" , label = \"DAC w/ offset & end of scale error\" ) ax . set_xlabel ( \"Input code\" ) ax . set_ylabel ( \"Output voltage [V]\" ) #ax.set_xticks(din) #ax.set_xticklabels(dinb_str, rotation=45) ax . grid ( True ) ax . set_title ( \"DAC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) # annotate the DAC errors on the plot ax . annotate ( r \"$\\epsilon_ {OFF} $: \" + \" {:.2f} LSB\" . format ( eoff ), xy = ( 0 , vout_off_eos [ 0 ]), xytext = ( 0 , vout_off_eos [ 0 ] - 0.1 ), arrowprops = dict ( arrowstyle = \"->\" ), fontsize = 12 ) ax . annotate ( r \"$\\epsilon_ {EOS} $: \" + \" {:.2f} LSB\" . format ( eeos ), xy = ( 2 ** n_bits - 1 , vout_off_eos [ 2 ** n_bits - 1 ]), xytext = ( 2 ** n_bits - 1 , vout_off_eos [ 2 ** n_bits - 1 ] + 0.1 ), arrowprops = dict ( arrowstyle = \"->\" ), fontsize = 12 ) # add an arrow showing the difference between the ideal DAC and the DAC with offset and end of scale error ax . annotate ( \"Gain error: {:.2f} %\" . format ( ger_pct ), xy = ( 0 , 0 ), xytext = ( 2 ** n_bits - 15 , 0 ), fontsize = 12 ) fig . tight_layout () DAC Non-Linear Errors This section presents the modelling of the non-linear errors that arise when modelling the transfer function of a DAC. These errors relate to a deviation of the real transfer function of the DAC towards the ideal DAC's transfer function, in which each step size can differ in height due to the inherent non-linearity that arises when quantizing a noisy signal! # define the DAC vref = 1.0 # define the reference voltage [V] n_bits = 4 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels # define an ideal DAC to compare the results idac = ideal_dac ( vref , n_bits ) # define the noise signal with a uniform distribution vq_var = ( vlsb ** 2 ) / 12 vq_std_dev = np . sqrt ( vq_var ) noise_factor = 2 dac_nonlinear = lambda x : idac ( x ) + noise_factor * uniform ( - vq_std_dev , vq_std_dev , len ( x )) #dac_nonlinear = lambda x: idac(x) + normal(loc=0, scale=vq_std_dev, size=len(x)) # define the input codes of the DAC din = np . arange ( 2 ** n_bits ) # convert the decimals to input binary words dinb = dec2bin ( din , n_bits ) # create the string representation of the input codes dinb_str = [ \"\" . join ([ str ( num ) for num in xv ]) for xv in dinb ] # compute the output voltages of the DAC vout = idac ( dinb ) vout_nonlinear = dac_nonlinear ( dinb ) # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 5 )) ax . plot ( din , vout , label = \"Ideal DAC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) #ax.step(din,vout, where=\"post\", label=\"Ideal DAC\", color=\"b\") ax . step ( din , vout_nonlinear , where = \"post\" , label = \"Non-Linear DAC\" , color = \"r\" ) ax . set_xticks ( din ) ax . set_yticks ( np . arange ( 0 , vref + vlsb , vlsb )) ax . set_xlabel ( \"Input code\" ) ax . set_ylabel ( \"Output voltage [V]\" ) ax . set_title ( \"DAC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) ax . grid ( True ) fig . tight_layout () As it is possible to observe, the exagerated transfer function non-linearities represented in the plot above feature variable output voltages for the non-ideal DAC, due to the quantization noise. The noise was multiplied by an amplification factor to better observe the effect of the quantization noise in the non-linear behaviour of the DAC's transfer function. The non-linear errors of converters can come in two forms: Differential Non-Linearity (DNL), given in Eq.(5), Integral Non-Linearity (INL), given in Eq.(6). The DNL and INL are measured in LSB units. The DNL provides a method of locally observing how much each step size changes in each transition. The INL on the other hand is the accumulation of the DNL up until the respective transition, and enables the measurement of the global step-size variability throughout every transition of the transfer function. In DACs, the INL and DNL, as well as any other kind of error, are measured in the vertical axis, where the voltage unit is. Eq. (4) presents the actual measured least significant bit step voltage of the DAC. $$ V_{LSB}' = \\frac{V_{OUT}'[2^N - 1] - V_{OUT}'[0]}{2^N - 1} \\hspace{4 pt} [V] \\hspace{10 pt} (4)$$ $$ DNL[n] = \\frac{V_{OUT}'[n+1] - V_{OUT}'[n]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-2] \\hspace{10 pt} (5) $$ $$ INL[n] = \\frac{V_{OUT}'[n] - n\\times V_{LSB}' - V_{OUT}'[0]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-1] \\hspace{10 pt} (6) $$ where $V_{OUT}'[n]$ is the output voltage of the real DAC at the $n^{th}$ transition and $V_{LSB}'$ is the measured step size of the non-ideal DAC. NOTE: The INL and DNL can only be calculated after removing the linear error sources (offset, and gain errors). # measure the real vlsb vlsb_measured = ( vout_nonlinear [ 2 ** n_bits - 1 ] - vout_nonlinear [ 0 ]) / ( 2 ** n_bits - 1 ) print ( \"The ideal vlsb is \" + \" {:.4f} V\" . format ( vlsb )) print ( \"The measured vlsb is \" + \" {:.4f} V\" . format ( vlsb_measured )) # measure the DNL of the DAC dnl = ( vout_nonlinear [ 1 ::] - vout_nonlinear [ 0 : - 1 ]) / vlsb_measured - 1 dnl_pythonic = np . diff ( vout_nonlinear ) / vlsb_measured - 1 assert np . allclose ( dnl , dnl_pythonic ), \"The DNL two methods give different results\" # assert that n is in [0, 2**n_bits-2] for the DNL assert len ( dnl ) == 2 ** n_bits - 1 , \"The DNL has a wrong length\" idx = np . arange ( 2 ** n_bits ) inl = ( vout_nonlinear - idx * vlsb_measured - vout_nonlinear [ 0 ]) / vlsb_measured # assert that n is in [0, 2**n_bits-1] for the INL assert len ( inl ) == 2 ** n_bits , \"The INL has a wrong length\" # plot the results fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) ax [ 0 ] . plot ( din [ 1 ::], dnl , label = \"DNL\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax [ 1 ] . plot ( din , inl , label = \"INL\" , marker = \"None\" , mfc = \"None\" , color = \"r\" ) ax [ 0 ] . set_xlabel ( \"Input code\" ) ax [ 1 ] . set_xlabel ( \"Input code\" ) ax [ 0 ] . set_ylabel ( \"DNL\" ) ax [ 1 ] . set_ylabel ( \"INL\" ) ax [ 0 ] . set_title ( \"DAC Non-Linearity\" ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) fig . tight_layout () fig . legend ( fancybox = False , frameon = False , fontsize = 8 ) The ideal vlsb is 0.0625 V The measured vlsb is 0.0632 V <matplotlib.legend.Legend at 0x134f82090> ADC Error Modelling ADC Linear Errors This section presents the modelling of the linear errors that arise when modelling the transfer function of a ADC. These errors relate to a deviation of the real transfer function of the ADC towards the ideal ADC's transfer function, in which each step size is exactly the same width! It is important to note that in this case (ADC), it is the transition voltlallges of the ADC that deviate from ideal ones, without ever changing step size! # define the ADC vref = 1.0 # define the reference voltage [V] n_bits = 4 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels # define an ideal DAC to compare the results roundf = np . round iadc = ideal_adc ( vref , n_bits , roundf ) # define the non-ideal ADC with linear errors # to procees with this step, we need to define # an ADC modelling function that is closer to the # its physical implementation - the model should include # the transition voltages as a characteristic parameter # and the input voltage will only provoke a transition # if the input voltage is greater than the corresponding # transition voltage # define an ADC with offset error voff = 0.05 adc_off , vt_off = nonideal_adc ( vref , n_bits , roundf = roundf , ofst = voff ) # define a ADC with end of scale error # note that the end of scale error # is actually directly related to # the gain error of the ADC # The gain error of the ADC is directly related to the # VREF voltage variation of the ADC. The lower the VREF # the lower will be vlsb, and as such, the higher will be # the end of scale error once the gain decreases. The # reciprocal is also true, the higher the VREF the higher # will be the Vlsb, and as such, the higher will be the # the gain of the ADC. vref_err = - 0.05 # -5% Vref variation true_vref = ( 1 + vref_err ) * vref adc_eos , vt_eos = nonideal_adc ( true_vref , n_bits , roundf = roundf ) # define a DAC with offset and end of scale error # to measure the true DAC gain error adc_off_eos , vt_off_eos = nonideal_adc ( true_vref , n_bits , roundf = roundf , ofst = voff ) # define the input voltages of the ADC vin = np . arange ( 0 , vref , vlsb ) vt_off = np . concatenate (([ 0 ], vt_off )) vt_eos = np . concatenate (([ 0 ], vt_eos )) vt_off_eos = np . concatenate (([ 0 ], vt_off_eos )) # create the string representation of the input codes # compute the output voltages of the 3 DACs dout = iadc ( vin ) dout_off = adc_off ( vin ) dout_eos = adc_eos ( vin ) dout_off_eos = adc_off_eos ( vin ) # convert the output codes to decimals dout_dec = bin2dec ( dout , n_bits ) dout_off_dec = bin2dec ( dout_off , n_bits ) dout_eos_dec = bin2dec ( dout_eos , n_bits ) dout_off_eos_dec = bin2dec ( dout_off_eos , n_bits ) # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 8 )) ax . plot ( vin , dout_dec , label = \"Ideal ADC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax . step ( vt_off , dout_off_dec , where = \"post\" , label = \"ADC with offset error\" , color = \"b\" ) ax . step ( vt_eos , dout_eos_dec , where = \"post\" , label = \"ADC with end of scale error\" , color = \"r\" ) ax . step ( vt_off_eos , dout_off_eos_dec , where = \"post\" , label = \"ADC with offset and end of scale error\" , color = \"g\" ) ax . set_xlabel ( \"Input voltage [V]\" ) ax . set_ylabel ( \"Output code\" ) ax . set_title ( \"ADC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) ax . grid ( True ) fig . tight_layout () # compute linear error ratios e_off = ( vout_off_eos [ 0 ] - vin [ 0 ]) / vlsb e_eos = ( vout_off_eos [ - 1 ] - vin [ - 1 ]) / vlsb ger_pct = (( vout_off_eos [ - 1 ] - vout_off_eos [ 0 ]) / ( vin [ - 1 ] - vin [ 0 ]) - 1 ) * 100 print ( \"The offset error is \" + \" {:.2f} LSB\" . format ( e_off )) print ( \"The end of scale error is \" + \" {:.2f} LSB\" . format ( e_eos )) print ( \"The gain error is \" + \" {:.2f} %\" . format ( ger_pct )) The offset error is 0 . 80 LSB The end of scale error is - 0 . 25 LSB The gain error is - 7 . 00 % ADC Non-Linear Errors This section presents the modelling of the non-linear errors that arise when modelling the transfer function of a ADC. These errors relate to a deviation of the real transfer function of the ADC towards the ideal ADC's transfer function, in which each step size can differ in width due to the inherent non-linearity that arises when quantizing a noisy signal! In a physical implementation, the intrinsic non-linearities that devices present are usually the main source of non-linear errors in ADCs, directly affecting the position of the transition voltages of the ADC. # define the ADC vref = 1.0 # define the reference voltage [V] n_bits = 5 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels roundf = np . round # define an ideal DAC to compare the results iadc = ideal_adc ( vref , n_bits , roundf ) # define the noise signal with a uniform distribution vq_var = ( vlsb ** 2 ) / 12 vq_std_dev = np . sqrt ( vq_var ) noise_factor = 2 adc_nonlinear , vtrans = nonideal_adc ( vref , n_bits , roundf = roundf , vnq = noise_factor * vq_std_dev ) # define the input voltages of the ADC vin = np . arange ( 0 , vref , vlsb ) # compute the output codes of the ADC dout = bin2dec ( iadc ( vin ), n_bits ) dout_nonlinear = bin2dec ( adc_nonlinear ( vin ), n_bits ) # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 8 )) ax . plot ( vin , dout , label = \"Ideal ADC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax . step ( vin , dout_nonlinear , where = \"post\" , label = \"non-linear ADC\" , color = \"r\" ) ax . set_xlabel ( \"Input voltage [V]\" ) ax . set_ylabel ( \"Output code\" ) ax . set_title ( \"ADC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) ax . grid ( True ) fig . tight_layout () From both figures observed in this ADC section (2.1 and 2.2), a very important conclusion can be taken: both linear and non-linear errors can lead to missing codes in the output of the ADC, which eventually leads to a loss of effective resolution of the converter. Analogously to the DAC section, the non-linear errors of converters can come in two forms: Differential Non-Linearity (DNL), given in Eq.(8), Integral Non-Linearity (INL), given in Eq.(9). The DNL and INL are measured in LSB units. The DNL provides a method of locally observing how much each step size changes in each transition voltage. The INL on the other hand is the accumulation of the DNL up until the respective transition, and enables the measurement of the global transition voltage step-size variability throughout every transition of the transfer function. In ADCs, the INL and DNL, as well as any other kind of error, are measured in the horizontal axis, where the voltage unit is. Eq. (7) presents the actual measured least significant bit step voltage of the ADC. $$ V_{LSB}' = \\frac{V_{T}'[2^N - 1] - V_{T}'[1]}{2^N - 2} \\hspace{4 pt} [V] \\hspace{10 pt} (7) $$ $$ DNL[n] = \\frac{V_{T}'[n+1] - V_{T}'[n]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-3] \\hspace{10 pt} (8) $$ $$ INL[n] = \\frac{V_{T}'[n] - n\\times V_{LSB}' - V_{T}'[1]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-2] \\hspace{10 pt} (9) $$ where $V_{T}'[n]$ is the transition voltage level of the real ADC at the $n^{th}$ transition and $V_{LSB}'$ is the measured least significant bit step size of the non-ideal ADC. In this case (ADC), there are $2^N$ intervals, but only $2^N - 1$ transition voltages, whereas in the DAC case there are $2^N$ intervals and $2^N$ output voltages NOTE: The INL and DNL can only be calculated after removing the linear error sources (offset, and gain errors). # compute the non linearity of the ADC # compute the measured vlsb assert len ( vtrans ) == 2 ** n_bits - 1 vlsb_measured = ( vtrans [ - 1 ] - vtrans [ 0 ]) / ( len ( vtrans ) - 1 ) print ( \"The ideal vlsb is \" + \" {:.4f} V\" . format ( vlsb )) print ( \"The measured vlsb is \" + \" {:.4f} V\" . format ( vlsb_measured )) # compute the DNL dnl = np . diff ( vtrans ) / vlsb_measured - 1 # assert that n is in [0, 2**n_bits-3] for the DNL assert len ( dnl ) == 2 ** n_bits - 2 , \"The number of DNL values is not correct\" # compute the INL idx = np . arange ( 0 , len ( vtrans ), 1 ) inl = ( vtrans - idx * vlsb_measured - vtrans [ 0 ]) / vlsb_measured # assert that n is in [0, 2**n_bits-2] for the INL assert len ( inl ) == 2 ** n_bits - 1 , \"The number of INL values is not correct\" The ideal vlsb is 0.0312 V The measured vlsb is 0.0319 V codes = np . arange ( 1 , len ( vtrans ), 1 ) # define the DNL transition codes # plot the results fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) ax [ 0 ] . plot ( codes , dnl , label = \"DNL\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax [ 1 ] . plot ( idx , inl , label = \"INL\" , marker = \"None\" , mfc = \"None\" , color = \"r\" ) ax [ 0 ] . set_xlabel ( \"Code\" ) ax [ 0 ] . set_ylabel ( \"DNL\" ) ax [ 1 ] . set_xlabel ( \"Code\" ) ax [ 1 ] . set_ylabel ( \"INL\" ) ax [ 0 ] . set_title ( \"DNL and INL\" ) ax [ 0 ] . legend ( fontsize = 8 , fancybox = False , frameon = False ) ax [ 1 ] . legend ( fontsize = 8 , fancybox = False , frameon = False ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) fig . tight_layout ()","title":"Signal-Converters"},{"location":"signal_converters/#signal-representation","text":"This practical class reviews some of the possible representations of a signal both in the time domain and in the frequency domain. All of the practical classes will take advantage of the Python programming language to study and model signal converters. The Jupyter Notebooks are a great way to segment the developed code, enabling an easier debugging and learning experience. The Jupyter Notebooks also enable the introduction of Markdown latex HTML notes in the middle of the code cells, offering a truly complete note-taking environment. import numpy as np import matplotlib.pyplot as plt import scienceplots plt . style . use ([ 'science' , 'notebook' ]) % matplotlib inline","title":"Signal Representation"},{"location":"signal_converters/#signal-representation-in-the-time-domain","text":"This section covers some nuances of the represenation of a signal (voltage/current/code) in the time-domain, throughout an independent axis representing time. Two main aspects of the representation of a signal are presented: 1- A signal can be decomposed on an infinite sum of fundamental trigonometric functions (sine and cosine), according to Fourier's Signal Theory; 2- The importance of using a differential signal chain is analysed to observe its impact on the overall distortion of the output signal. # define the number of points for the simulation # NOTE: This enables a better control of the simulation time and memmory resources Np = 1001 # define time base Fs = 100e3 Ts = 1 / Fs tD = np . arange ( 0 , Np ) * Ts ; # (0:Np-1) == np.arange(0,Np) tD # define the signals Amp1 = 1 f1 = 1e3 phase1 = 0 phase1_rad = np . deg2rad ( phase1 ) x1 = Amp1 * np . sin ( 2 * np . pi * f1 * tD + phase1_rad ) x1 # visualize the signals fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 4 )) ax . plot ( tD , x1 , lw = 2 , ls = \"-\" , color = 'b' , ms = 3 ) ax . grid ( True ) ax . set_ylabel ( \"Voltage (V)\" ) ax . set_xlabel ( \"Time (s)\" ) ax . legend () plt . show () # changing the frequency of the signal # define the new signal Amp2 = 1 f2 = 0.5e3 phase2 = 0 phase2_rad = np . deg2rad ( phase1 ) x2 = Amp2 * np . sin ( 2 * np . pi * f2 * tD + phase1_rad ) x2 # visualize the signals fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 4 )) ax . plot ( tD , x2 , lw = 2 , ls = \"-\" , color = \"r\" , ms = 3 ) ax . grid ( True ) ax . set_ylabel ( \"Voltage (V)\" ) ax . set_xlabel ( \"Time (s)\" ) ax . legend () plt . show () # observing 2 sinusoids in the same plot # second harmonic Amp2 = 0.5 f2 = 2e3 phase2_rad = np . deg2rad ( 0 ) x2 = Amp2 * np . sin ( 2 * np . pi * f2 * tD + phase2_rad ) # third harmonic Amp3 = 0.2 f3 = 3e3 phase3_rad = np . deg2rad ( 0 ) x3 = Amp3 * np . sin ( 2 * np . pi * f3 * tD + phase3_rad ) Visualize the signals and infer on the veracity of the Fourier Series representation of the signal - any signal can be represented as a sum of sinusoids! In this case, the sum of x1 with x3 can almost generate a digital signal denominated as a square wave. fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , x1 , lw = 2 , ls = \"-\" , color = \"b\" , marker = \"None\" , ms = 3 , label = \"x1\" ) ax [ 0 ] . plot ( tD , x2 , lw = 2 , ls = \"-\" , color = \"g\" , marker = \"None\" , ms = 3 , label = \"x2\" ) ax [ 0 ] . plot ( tD , x3 , lw = 2 , ls = \"-\" , color = \"r\" , marker = \"None\" , ms = 3 , label = \"x3\" ) ax [ 0 ] . set_title ( \"x1(t), x3(t)\" ) ax [ 0 ] . legend ( frameon = True , facecolor = \"pink\" , edgecolor = \"none\" ) ax [ 0 ] . grid ( True ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 1 ] . plot ( tD , x1 + x2 , lw = 2 , ls = \"-\" , color = \"k\" , marker = \"None\" , ms = 3 ) ax [ 1 ] . set_title ( \"x1(t) + x2(t)\" ) ax [ 1 ] . grid ( True ) ax [ 1 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 2 ] . plot ( tD , x1 + x3 , lw = 2 , ls = \"-\" , color = \"k\" , marker = \"None\" , ms = 3 ) ax [ 2 ] . set_title ( \"x1(t) + x3(t)\" ) ax [ 2 ] . grid ( True ) ax [ 2 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 2 ] . set_xlabel ( \"Time (s)\" ) fig . tight_layout () plt . show () From the above signal representations, two conclusions can be made: The odd harmonics allow to preserve the area ratio of the positive wave and negative wave of the signal in relation to the average value.In other words, the odd harmonics allow the signal to preserve its symmetry. The same is not true for the even harmonics. The even harmonics do not ensure that the signal preserves its symmetry in relation to its average value. Any signal processing chain, or signal conversion chain should always be differential, in which the processed signals feature a phase of 180 \u00ba between each other. Differential signals enable the natural cancellation of the even harmonic components of the signal, significantly improving the linearity of the signal at the output of the signal processign chain. Demo: Given the signal: $$ s(t) = a_1 sin(2\\pi f_1t + \\phi_1 ) + (a_2 sin(2\\pi f_1t + \\phi_2 ))^2 + (a_3 *sin(2\\pi f_1t + \\phi_3 ))^3 $$ where: $f_2 = 2f_1$ and $f_3=3f_1$ The differential rendition of this signal would give us: $$ s(t) - s(t+180\u00ba) = 2a_1 sin(2\\pi f_1t + \\phi_1) + \\frac{4a_3^2}{3} sin(2\\pi 3f_1t + \\phi_3) + s_{DC} $$ As it is possible to observe, the even harmonic components are cancelled, and thus the distortion is reduced.","title":"Signal Representation in the Time-Domain"},{"location":"signal_converters/#signal-representation-in-the-frequency-domain","text":"This section covers the representation of the signals defined in the previous section in the frequency domain. The signal representation defined by Fourier's series holds true in the frequency spectrum. A depiction of this is the representation of the sum of the x1, x2 and x3 signals in the frequency spectrum, featuring the resulting three dirac distributions. The frequencies of these distributions correspond to the fundamental, second and third harmonics of the signal resulting from the sum of the signals. # spectral analysis using fft - fast fourier transform yt = x1 + x2 + x3 yf = np . abs ( np . fft . fftshift ( np . fft . fft ( yt ) / Np )) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform fD = np . fft . fftshift ( np . fft . fftfreq ( Np , Ts )) # [Hz] # frequency axis power_yf = ( yf * yf ) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf_dB = 10 * np . log10 ( power_yf ) # [dB] - convert the power spectrum to dB power_yf_dB yf2 = np . abs ( np . fft . fftshift ( np . fft . fft ( x1 ) / Np )) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yf2 = ( yf2 * yf2 ) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yf2_dB = 10 * np . log10 ( power_yf2 ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) f_scale = 1e3 # frequency scale [Hz] p_scale = 1 # power scale in [dB] ax [ 0 ] . stem ( fD [ fD >= 0 ] / f_scale , power_yf_dB [ fD >= 0 ] / p_scale , bottom = np . min ( power_yf_dB / p_scale ), #use_line_collection=True, linefmt = \"b-\" , markerfmt = \"none\" , basefmt = \"r-\" , ) ax [ 0 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 0 ] . set_ylabel ( \"Power (dB)\" ) ax [ 0 ] . set_title ( \"Frequency spectrum of x1+x2+x3\" ) f_lim = 4e3 / f_scale # limitting frequency ax [ 0 ] . set_xlim ([ 0 , f_lim ]) ax [ 0 ] . set_ylim ([ - 40 , 0 ]) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , power_yf2_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_xlim ([ 0 , f_lim ]) fig . tight_layout () As it is possible to observe, the plot of x1 in black (the second curve) gives us a spectral dirac that is not concentrated on a single frequency bin, and rather spreads throughout the frequency with decreasing power throughout the spectrum.","title":"Signal Representation in the Frequency-Domain"},{"location":"signal_converters/#one-possible-solution-windows","text":"The use of a window defining the simulation time window in which the spectrum of the signal will be analysed can significantly improve the spectral quality of the observed signal in the frequency spectrum. The following example uses a Blackman-Harris window, multiplying it to the signal in the time-domain. As such, the obtained signal's frequency spectrum features a much more perceptible definition of the central frequency of each signal's harmonic. The resulting computed spectral power of each harmonic appears to be lower than the spectrum obtained without the use of a window. This is a mere appearance, and it results from the fact that the Blackman-Harris window causes the power of each harmonic to be spread throughout 5 frequency bins (2 bins before, the central bin of the harmonic and 2 bins after). NOTE: Another solution (which is actually preferred) would be to use coherent sampling - ensuring the sampling frequency is simultaneously a prime number and a multiple of the input signal's frequency. Both solutions can also be used simultaneously. # applying a blackman harris window to # better observe the signal's spectrum from scipy import signal window = signal . windows . blackmanharris ( Np ) fig , ax = plt . subplots ( 1 , figsize = ( 4 , 4 )) ax . set_xlabel ( 'Samples' ) ax . set_ylabel ( 'Window Amplitude' ) plt . plot ( window ) # spectral analysis using fft - fast fourier transform ytbm = yt * signal . windows . blackmanharris ( Np ) yfbm = np . abs ( np . fft . fftshift ( np . fft . fft ( ytbm ) / Np )) # [V] # voltage in the frequency axis # NOTE: fft(yf) is divided by Np in order to normalize the resulting frequency spectrum from the digital fourier transform power_yfbm = ( yfbm * yfbm ) # [V^2] - square the voltage spectrum to obtain the power spectrum power_yfbm_dB = 10 * np . log10 ( power_yfbm ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) f_scale = 1e3 # frequency scale [Hz] p_scale = 1 # power scale in [dB] ax [ 0 ] . stem ( fD [ fD >= 0 ] / f_scale , power_yf_dB [ fD >= 0 ] / p_scale , bottom = np . min ( power_yf_dB / p_scale ), #use_line_collection=True, linefmt = \"b-\" , markerfmt = \"none\" , basefmt = \"r-\" , ) ax [ 0 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 0 ] . set_ylabel ( \"Power (dB)\" ) ax [ 0 ] . set_title ( \"Frequency spectrum of x1+x2+x3\" ) f_lim = 4e3 / f_scale # limitting frequency ax [ 0 ] . set_xlim ([ 0 , f_lim ]) ax [ 0 ] . set_ylim ([ - 40 , 0 ]) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , power_yf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"k\" , marker = \"none\" , ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , power_yfbm_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"r\" , marker = \"none\" , ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_xlim ([ 0 , f_lim ]) fig . tight_layout ()","title":"One possible solution: Windows!"},{"location":"signal_converters/#noise-sources-and-representation","text":"To perform a more accurate simulation of the signal converters that are going to be studied in this course, a superposition of noise to the processed signal is inevitable and required. The process of quantizing an ideal signal without any supperposed noise will inevitably add a quantization error to the signal, as seen in the following equation. $$ s_Q(t) = s(t) + \\epsilon_Q(t) \\hspace{10pt} (1) $$ where $\\epsilon_Q(t)$ is the quantization error, $s_Q(t)$ is the quantized signal and $s(t)$ is the processed signal. However, in reality all analog signals are subject to some form of noise. If the processed signal features a given level of noise power superposed to it, and the signal converter/quantizer features an high-enough quantization precision, the quantization error can actually be well approximated by white noise, as seen in (2). White noise is present throughout all the spectrum of both the signal and the quantizing system. It features a constant power spectral density throughout the system's operation spectrum, and as such it is very easy to model through a uniform distribution. $$ s_Q(t) = (x(t) + n(t)) + \\epsilon_Q(t) = x(t) + v_{NQ}(t) \\hspace{10pt} (2) $$ where $x(t)$ is the processed signal, $n(t)$ is the noise superposed to the processed signal and $v_{NQ}(t)$ is the quantization white noise approximated by the sum of $n(t)$ and $\\epsilon_Q(t)$. from numpy.random import normal , uniform # random numbers fitted into a normal or uniform distribution import seaborn as sns # to observe the noise signal's histogram # define the quantizer's main parameters nbits = 4 # number of bits vref = 0.9 # reference voltage [V] vlsb = vref / ( 2 ** nbits ) # fundamental step votlage of the quantizer [V] # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = ( vlsb ** 2 ) / 12 # quantization noise variance [V] vqstddev = np . sqrt ( vqvar ) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = uniform ( - vqstddev , vqstddev , Np ) # quantization noise signal with a uniform dist (white noise)[V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np . abs ( np . fft . fftshift ( np . fft . fft ( vq ) / Np )) # [V] # voltage in the frequency axis pqf = ( vqf * vqf ) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np . log10 ( pqf ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , vq , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 0 ] . set_xlabel ( \"Time (s)\" ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 0 ] . set_title ( \"Quantization noise signal\" ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , pqf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"gray\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_title ( \"Quantization noise signal's frequency spectrum\" ) sns . histplot ( vq , ax = ax [ 2 ], color = \"gray\" ) ax [ 2 ] . hlines ( y = np . mean ( np . histogram ( vq , bins = 10 )[ 0 ]), xmin =- vqstddev , xmax = vqstddev , color = \"r\" ) ax [ 2 ] . set_xlabel ( \"Voltage (V)\" ) ax [ 2 ] . set_ylabel ( \"Count\" ) ax [ 2 ] . set_title ( \"Quantization noise signal's histogram\" ) ax [ 0 ] . grid () ax [ 1 ] . grid () ax [ 2 ] . grid ( False ) fig . tight_layout () # define the noise parameters vqmean = 0 # quantizer's mean voltage [V] vqvar = ( vlsb ** 2 ) / 12 # quantization noise variance [V] vqstddev = np . sqrt ( vqvar ) # quantization noise standard deviation (Vqrms) [V] # generate the noise signal vq = normal ( vqmean , vqstddev , Np ) # gaussian noise signal with a normal dist [V] #sns.distplot(vq, bins=10, hist_kws={\"edgecolor\":\"black\"}) # frequency domain analysis of the white noise signal vqf = np . abs ( np . fft . fftshift ( np . fft . fft ( vq ) / Np )) # [V] # voltage in the frequency axis pqf = ( vqf * vqf ) # [V^2] - square the voltage spectrum to obtain the power spectrum pqf_dB = 10 * np . log10 ( pqf ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram #! OBSERVE A NOISE SIGNAL DEFINED USNG A NORMAL DISTRIBUTION fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , vq , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 0 ] . set_xlabel ( \"Time (s)\" ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 0 ] . set_title ( \"Gaussian noise signal\" ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , pqf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"gray\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_title ( \"Gaussian noise signal's frequency spectrum\" ) sns . histplot ( vq , ax = ax [ 2 ], color = \"gray\" , edgecolor = \"gray\" , kde = True ) #ax[2].vlines( # x=np.mean(vq), # ymin=0, ymax=np.mean(np.histogram(vq, bins=10)[0]), color=\"r\") ax [ 2 ] . set_xlabel ( \"Voltage (V)\" ) ax [ 2 ] . set_ylabel ( \"Count\" ) ax [ 2 ] . set_title ( \"Gaussian noise signal's histogram\" ) ax [ 0 ] . grid () ax [ 1 ] . grid () ax [ 2 ] . grid ( False ) fig . tight_layout () # let us now superpose the noise signal to the x1 signal and observe # the resulting signal's frequency spectrum, histogram and time domain Amp1 = 0.2 # amplitude of the sine wave [V] x1 = Amp1 * np . sin ( 2 * np . pi * f1 * tD + phase1_rad ) # [V] - sine wave vq = uniform ( - vqstddev , vqstddev , Np ) # quantization noise signal with a uniform dist (white noise)[V] st = x1 + vq stf = np . abs ( np . fft . fftshift ( np . fft . fft ( st ) / Np )) # [V] # voltage in the frequency axis ptf = ( stf * stf ) # [V^2] - square the voltage spectrum to obtain the power spectrum ptf_dB = 10 * np . log10 ( ptf ) # [dB] - convert the power spectrum to dB # plot the frequency spectrum # plot the noise signal in the time domain, frequency domain # and its histogram fig , ax = plt . subplots ( 3 , 1 , figsize = ( 10 , 10 )) ax [ 0 ] . plot ( tD , st , ls = \"-\" , color = \"k\" , marker = \"none\" ) ax [ 0 ] . set_xlabel ( \"Time (s)\" ) ax [ 0 ] . set_ylabel ( \"Voltage (V)\" ) ax [ 0 ] . set_title ( r \"Quantized signal - $s(t)$\" ) ax [ 1 ] . plot ( fD [ fD >= 0 ] / f_scale , ptf_dB [ fD >= 0 ] / p_scale , ls = \"-\" , color = \"gray\" , marker = \"none\" ) ax [ 1 ] . set_xlabel ( \"Frequency (KHz)\" ) ax [ 1 ] . set_ylabel ( \"Power (dB)\" ) ax [ 1 ] . set_title ( \"Quantized signal's frequency spectrum\" ) sns . histplot ( st , ax = ax [ 2 ], color = \"gray\" , kde = True ) ax [ 2 ] . set_xlabel ( \"Voltage (V)\" ) ax [ 2 ] . set_ylabel ( \"Count\" ) ax [ 2 ] . set_title ( \"Quantized signal's histogram\" ) ax [ 0 ] . grid () ax [ 1 ] . grid () ax [ 2 ] . grid ( False ) fig . tight_layout ()","title":"Noise Sources and Representation"},{"location":"signal_converters/#ideal-adc-and-dac-modelling","text":"The models of an ideal ADC and DAC biased with a Vref voltage and N bits of resolution are presented in this notebook. The covnersion functions of both converters were created using the lambda programming style. Using this style, the creator function for the ADC or DAC receives the 2 fundamental parameters defining these ideal electronic systems: Vref - The reference/biasing voltage of the converter; Nbits - the number of bits of the converter system (its digital resolution). The converter then returns a function that depending on its input will generate an output code or voltage, for the ADC or DAC, respectively. from functools import reduce import numpy as np import matplotlib.pyplot as plt import scienceplots plt . style . use ([ 'science' , 'notebook' ]) % matplotlib inline # define the function to convert a binary vector to decimal def bin2dec ( x , width ): \"\"\"Convert a numpy array from binary to decimal. IF the input is an array of binary arrays, the returned output is an array of the corresponding decimals in their corresponding indexes. Parameters: x: numpy array b: base of the number system \"\"\" x = np . array ( x ) if x . size == width : assert len ( x ) == width , \"The length of the vector must be equal to the number of bits\" return reduce ( lambda x , b : 2 * x + b , x ) assert len ( x [ 0 ]) == width , \"The length of the vector must be equal to the number of bits\" return np . array ( np . array ([ reduce ( lambda xval , b : 2 * xval + b , xval ) for xval in x ])) def dec2bin ( x , width ): \"\"\"Convert a numpy array from decimal to binary If the input is an array of decimals, the returned binary arrays are the codes corresponding to each decimal in its corresponding index. Parameters: x: numpy array b: base of the number system \"\"\" x = np . array ( x ) if x . size == 1 : return np . array ([ int ( c ) for c in np . binary_repr ( x , width = width )]) return np . array ([ np . array ([ int ( c ) for c in np . binary_repr ( subx , width = width )]) for subx in x ]) # test x = np . array ([ 1 , 0 , 1 , 1 , 0 , 1 ]) assert bin2dec ( x , 6 ) == 45 x = np . array ([ 1 , 0 , 1 ]) assert bin2dec ( x , 3 ) == 5","title":"Ideal ADC and DAC modelling"},{"location":"signal_converters/#digital-to-analog-converter-modelling","text":"This section presents the definition of the ideal model for the transfer function of a DAC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (1). There are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$ V_{OUT}(D_{in}) = base_{10}{D_{in}}*V_{LSB}\\hspace{10 pt} (1) $$ where $D_{in}$ is the input binary word of the DAC, $V_{LSB}$ is the Least Significant Bit step voltage and $V_{OUT}$ is the output voltage of the DAC. # Modelling an ideal Digital to Analog Converter (DAC) vref = 5 # The biasing voltage of the DAC [V] n_bits = 3 # The resolution of the ideal DAC # define the ideal model of a DAC using lambda programming def ideal_dac ( vref : float , n_bits : int ): \"\"\"Define the transfer function of an ideal DAC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. Returns: function(Din): the lambda function defining the transfer function of the DAC \"\"\" vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels return lambda x : bin2dec ( x , n_bits ) * vlsb # return the converter funtion # define the DAC's transfer function idac = ideal_dac ( vref , n_bits ) # define the array of decimal input codes # belonging to [0, 2^{n_bits}-1] x = np . arange ( 2 ** n_bits ) print ( x ) # convert the input codes array # from decimal to binary using arrays of 1s and 0s x_bin = np . array ([ dec2bin ( i , n_bits ) for i in x ]) # create the string representation of the binary words x_bin_str = [ \"\" . join ([ str ( num ) for num in xv ]) for xv in x_bin ] print ( x_bin ) print ( idac ( x_bin [ 1 ])) # get the corresponding output voltages # of the DAC for each corresponding input code y = idac ( x_bin ) # plot the transfer function of the ideal DAC fig , ax = plt . subplots ( 2 , 1 , figsize = ( 8 , 8 )) ax [ 0 ] . plot ( x_bin_str , y , marker = \"o\" , mfc = \"None\" ) # mfc == marker face color ax [ 0 ] . set_xticklabels ( x_bin_str , rotation = 45 ) ax [ 0 ] . set_yticks ( y ) ax [ 0 ] . set_xlabel ( 'Code' ) ax [ 0 ] . set_ylabel ( 'Voltage (V)' ) ax [ 0 ] . set_title ( 'Ideal DAC Transfer Function (Vout(Din))' ) ax [ 0 ] . grid ( True ) ax [ 1 ] . step ( x_bin_str , y , marker = \"None\" , color = \"k\" , label = \"floor\" , where = \"post\" ) # note that the step function of the DAC is always a post step! ax [ 1 ] . set_xticklabels ( x_bin_str , rotation = 45 ) ax [ 1 ] . set_yticks ( y ) ax [ 1 ] . set_xlabel ( 'Code' ) ax [ 1 ] . set_ylabel ( 'Voltage (V)' ) ax [ 1 ] . grid ( True ) fig . tight_layout () [0 1 2 3 4 5 6 7] [[0 0 0] [0 0 1] [0 1 0] [0 1 1] [1 0 0] [1 0 1] [1 1 0] [1 1 1]] 0.625 /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:20: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[0].set_xticklabels(x_bin_str, rotation = 45) /var/folders/vv/xctyh4bd2td6k2w_gvh_t2vr0000gn/T/ipykernel_26609/887913226.py:28: UserWarning: set_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator. ax[1].set_xticklabels(x_bin_str, rotation = 45)","title":"Digital-to-Analog Converter Modelling"},{"location":"signal_converters/#analog-to-digital-converter-modelling","text":"This section presents the definition of the ideal model for the transfer function of a ADC. The corresponding transfer function that is implemented through a lambda programming style can be observed in (2). Once again, there are other possible solutions, such as using an object-oriented programming approach by defining a DAC object with a \"convert\" method. $$ D_{OUT}(V_{in}, f_{Round}) = base_2{f_{Round}(V_{in}/V_{LSB})} \\hspace{10 pt} (2) $$ where $V_{in}$ is the input voltage of the ADC, $V_{LSB}$ is the Least Significant Bit step voltage and $D_{OUT}$ is the output digital code of the ADC. $f_{Round}$ is the rounding function that the ADC implements in practice, and this function can be one of three possible solutions: a) round(.), rounding to the nearest decimal; b) ceil(.), rounding to the highest decimal; c) floor(.), rounding to the lowest decimal. In this case, equation (2) defines an ADC transfer function that returns the output code in the form of a binary digital word, to provide consistency with the presented code below. It is important to note that the the rounding function is parsed as an input to the ADC's transfer function for practical, low-code purposes. # modelling an ideal ADC vref = 5 # V n_bits = 3 # bits def ideal_adc ( vref : float , nbits : int , roundf ): \"\"\"Define the transfer function of an ideal ADC biased by vref and presenting an n_bits resolution. Parameters: vref (float): The biasing voltage of the electronic system. n_bits (int): The resolution of the DAC. roundf (function): The rounding function to be used. Returns: function(Vin): the lambda function defining the transfer function of the ADC \"\"\" assert roundf in [ np . round , np . ceil , np . floor ], \"The round function must be numpy.floor, numpy.ceil or numpy.round\" vlsb = vref / ( 2 ** nbits ) return lambda x : dec2bin ( roundf ( x / vlsb ) . astype ( int ), nbits ) iadc = ideal_adc ( vref , n_bits , np . round ) iadc_ceil = ideal_adc ( vref , n_bits , np . ceil ) iadc_floor = ideal_adc ( vref , n_bits , np . floor ) print ( iadc ( np . array ([ 0 , 1 , 2 , 3 , 4 ]))) x = np . arange ( 0 , vref , vref / 2 ** n_bits ) y = iadc ( x ) y_str = [ \"\" . join ([ str ( num ) for num in yv ]) for yv in y ] print ( y_str ) fig , ax = plt . subplots ( 2 , 1 , figsize = ( 8 , 8 )) ax [ 0 ] . plot ( x , y_str , marker = \"o\" , color = \"k\" , mfc = \"None\" ) ax [ 0 ] . set_xticks ( x ) ax [ 0 ] . set_xticklabels ( x , rotation = 45 ) ax [ 0 ] . set_xlabel ( 'Voltage (V)' ) ax [ 0 ] . set_ylabel ( 'Code' ) ax [ 1 ] . step ( x , y_str , marker = \"None\" , color = \"k\" , label = \"round\" , where = \"mid\" ) y = iadc_ceil ( x ) y_str = [ \"\" . join ([ str ( num ) for num in yv ]) for yv in y ] ax [ 1 ] . step ( x , y_str , marker = \"None\" , color = \"r\" , label = \"ceil\" , where = \"post\" ) ax [ 1 ] . set_xticks ( x ) ax [ 1 ] . set_xticklabels ( x , rotation = 45 ) ax [ 1 ] . set_xlabel ( 'Voltage (V)' ) ax [ 1 ] . set_ylabel ( 'Code' ) y = iadc_floor ( x ) y_str = [ \"\" . join ([ str ( num ) for num in yv ]) for yv in y ] ax [ 1 ] . step ( x , y_str , marker = \"None\" , color = \"b\" , label = \"floor\" , where = \"pre\" ) ax [ 1 ] . set_xticks ( x ) ax [ 1 ] . set_xticklabels ( x , rotation = 45 ) ax [ 1 ] . set_xlabel ( 'Voltage (V)' ) ax [ 1 ] . set_ylabel ( 'Code' ) ax [ 0 ] . set_xlim ([ 0 , vref ]) ax [ 1 ] . set_xlim ([ 0 , vref ]) fig . tight_layout () ax [ 0 ] . set_title ( \"Dout(Vin)\" ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) ax [ 1 ] . legend () fig . tight_layout () [[0 0 0] [0 1 0] [0 1 1] [1 0 1] [1 1 0]] ['000', '001', '010', '011', '100', '101', '110', '111']","title":"Analog-to-Digital Converter Modelling"},{"location":"signal_converters/#linear-and-non-linear-errors-in-dacs-and-adcs","text":"The introduction of quantization noise in the ADC or DAC introduces errors associated with the quantization step size defining the true characteristic of the ADC or DAC transfer function. This notebook presents the modelling and study of the two main types of errors in converters: linear and non-linear. # mathematical computing import numpy as np from scipy import signal # to generate the noise signal import seaborn as sns # to observe the noise signal's histogram from numpy.random import uniform , normal # random numbers fitted into a uniform distribution # plotting import matplotlib.pyplot as plt # import the models and utilities functions from utils import ideal_dac , ideal_adc , nonideal_adc , dec2bin , bin2dec import scienceplots plt . style . use ([ 'science' , 'notebook' ])","title":"Linear and Non-linear Errors in DACs and ADCs"},{"location":"signal_converters/#dac-errors-modelling","text":"","title":"DAC Errors Modelling"},{"location":"signal_converters/#dac-linear-errors","text":"This section presents the modelling of the linear errors that arise when modelling the transfer function of a DAC. These errors relate to a deviation of the real transfer function of the DAC towards the ideal DAC's transfer function, in which each step size is exactly the same height! # define the DAC vref = 1.0 # define the reference voltage [V] n_bits = 5 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels # define an ideal DAC to compare the results idac = ideal_dac ( vref , n_bits ) # define a DAC with offset error voff = 0.05 dac_off = lambda x : idac ( x ) + voff # define a DAC with end of scale error # note that the end of scale error # is actually directly related to # the gain error of the DAC gain_err = - 0.1 target_gain = 1.0 + gain_err dac_eos = lambda x : idac ( x ) * target_gain # define a DAC with offset and end of scale error # to measure the true DAC gain error dac_off_eos = lambda x : idac ( x ) * target_gain + voff # define the input codes of the 3 DACs din = np . arange ( 2 ** n_bits ) # convert the decimals to input binary words dinb = dec2bin ( din , n_bits ) # create the string representation of the input codes dinb_str = [ \"\" . join ([ str ( num ) for num in xv ]) for xv in dinb ] # compute the output voltages of the 3 DACs vout = idac ( dinb ) vout_off = dac_off ( dinb ) vout_eos = dac_eos ( dinb ) vout_off_eos = dac_off_eos ( dinb ) To accurately measure the linear error of DACs it is only necessary to observe the initial and final points of the transfer function. From these points three measurements can be performed: Offset Error, represented in Eq.(1) End of Scale Error, represented in Eq.(2) Gain Error, represented in Eq.(3) The Gain Error of the DAC is directly related to both the End of Scale and Offset Errors of the DAC and is derived from them. The errors are measured in LSB units. $$ \\epsilon_{OFF} = \\frac{V_{OUT}'[T_0] - V_{OUT}[T_0]}{V_{LSB}} \\hspace{4 pt} [LSB] \\hspace{10 pt} (1) $$ $$ \\epsilon_{EOS} = \\frac{V_{OUT}'[T_{2^N - 1}] - V_{OUT}[T_{2^N - 1}]}{V_{LSB}} \\hspace{4 pt} [LSB] \\hspace{10 pt} (2) $$ $$ GER_{[\\%]} = \\left(\\frac{V_{OUT}'[T_{2^N - 1}] - V_{OUT}'[T_{0}]}{V_{OUT}[T_{2^N - 1}] - V_{OUT}[T_{0}]} - 1\\right)\\times100 \\hspace{10 pt} (3) $$ where $V_{OUT}[T_i]$ and $V_{OUT}'[T_i]$ is the output voltage of the ideal DAC and real DAC at the $i^{th}$ transition, respectively. # measure the DAC errors eoff = ( vout_off_eos [ 0 ] - vout [ 0 ]) / vlsb eeos = ( vout_off_eos [ 2 ** n_bits - 1 ] - vout [ 2 ** n_bits - 1 ]) / vlsb ger_pct = (( vout_off_eos [ 2 ** n_bits - 1 ] - vout_off_eos [ 0 ]) / ( vout [ 2 ** n_bits - 1 ] - vout [ 0 ]) - 1 ) * 100 print ( \"The offset error is {:.2f} LSB\" . format ( eoff )) print ( \"The end of scale error is {:.2f} LSB\" . format ( eeos )) print ( \"The gain error is {:.2f} %\" . format ( ger_pct )) The offset error is 1 . 60 LSB The end of scale error is - 1 . 50 LSB The gain error is - 10 . 00 % # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 8 )) ax . plot ( din , vout , label = \"Ideal DAC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax . step ( din , vout_off , where = \"post\" , label = \"DAC w/ offset error\" ) ax . step ( din , vout_eos , where = \"post\" , label = \"DAC w/ end of scale error\" ) ax . step ( din , vout_off_eos , where = \"post\" , label = \"DAC w/ offset & end of scale error\" ) ax . set_xlabel ( \"Input code\" ) ax . set_ylabel ( \"Output voltage [V]\" ) #ax.set_xticks(din) #ax.set_xticklabels(dinb_str, rotation=45) ax . grid ( True ) ax . set_title ( \"DAC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) # annotate the DAC errors on the plot ax . annotate ( r \"$\\epsilon_ {OFF} $: \" + \" {:.2f} LSB\" . format ( eoff ), xy = ( 0 , vout_off_eos [ 0 ]), xytext = ( 0 , vout_off_eos [ 0 ] - 0.1 ), arrowprops = dict ( arrowstyle = \"->\" ), fontsize = 12 ) ax . annotate ( r \"$\\epsilon_ {EOS} $: \" + \" {:.2f} LSB\" . format ( eeos ), xy = ( 2 ** n_bits - 1 , vout_off_eos [ 2 ** n_bits - 1 ]), xytext = ( 2 ** n_bits - 1 , vout_off_eos [ 2 ** n_bits - 1 ] + 0.1 ), arrowprops = dict ( arrowstyle = \"->\" ), fontsize = 12 ) # add an arrow showing the difference between the ideal DAC and the DAC with offset and end of scale error ax . annotate ( \"Gain error: {:.2f} %\" . format ( ger_pct ), xy = ( 0 , 0 ), xytext = ( 2 ** n_bits - 15 , 0 ), fontsize = 12 ) fig . tight_layout ()","title":"DAC Linear Errors"},{"location":"signal_converters/#dac-non-linear-errors","text":"This section presents the modelling of the non-linear errors that arise when modelling the transfer function of a DAC. These errors relate to a deviation of the real transfer function of the DAC towards the ideal DAC's transfer function, in which each step size can differ in height due to the inherent non-linearity that arises when quantizing a noisy signal! # define the DAC vref = 1.0 # define the reference voltage [V] n_bits = 4 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels # define an ideal DAC to compare the results idac = ideal_dac ( vref , n_bits ) # define the noise signal with a uniform distribution vq_var = ( vlsb ** 2 ) / 12 vq_std_dev = np . sqrt ( vq_var ) noise_factor = 2 dac_nonlinear = lambda x : idac ( x ) + noise_factor * uniform ( - vq_std_dev , vq_std_dev , len ( x )) #dac_nonlinear = lambda x: idac(x) + normal(loc=0, scale=vq_std_dev, size=len(x)) # define the input codes of the DAC din = np . arange ( 2 ** n_bits ) # convert the decimals to input binary words dinb = dec2bin ( din , n_bits ) # create the string representation of the input codes dinb_str = [ \"\" . join ([ str ( num ) for num in xv ]) for xv in dinb ] # compute the output voltages of the DAC vout = idac ( dinb ) vout_nonlinear = dac_nonlinear ( dinb ) # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 5 )) ax . plot ( din , vout , label = \"Ideal DAC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) #ax.step(din,vout, where=\"post\", label=\"Ideal DAC\", color=\"b\") ax . step ( din , vout_nonlinear , where = \"post\" , label = \"Non-Linear DAC\" , color = \"r\" ) ax . set_xticks ( din ) ax . set_yticks ( np . arange ( 0 , vref + vlsb , vlsb )) ax . set_xlabel ( \"Input code\" ) ax . set_ylabel ( \"Output voltage [V]\" ) ax . set_title ( \"DAC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) ax . grid ( True ) fig . tight_layout () As it is possible to observe, the exagerated transfer function non-linearities represented in the plot above feature variable output voltages for the non-ideal DAC, due to the quantization noise. The noise was multiplied by an amplification factor to better observe the effect of the quantization noise in the non-linear behaviour of the DAC's transfer function. The non-linear errors of converters can come in two forms: Differential Non-Linearity (DNL), given in Eq.(5), Integral Non-Linearity (INL), given in Eq.(6). The DNL and INL are measured in LSB units. The DNL provides a method of locally observing how much each step size changes in each transition. The INL on the other hand is the accumulation of the DNL up until the respective transition, and enables the measurement of the global step-size variability throughout every transition of the transfer function. In DACs, the INL and DNL, as well as any other kind of error, are measured in the vertical axis, where the voltage unit is. Eq. (4) presents the actual measured least significant bit step voltage of the DAC. $$ V_{LSB}' = \\frac{V_{OUT}'[2^N - 1] - V_{OUT}'[0]}{2^N - 1} \\hspace{4 pt} [V] \\hspace{10 pt} (4)$$ $$ DNL[n] = \\frac{V_{OUT}'[n+1] - V_{OUT}'[n]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-2] \\hspace{10 pt} (5) $$ $$ INL[n] = \\frac{V_{OUT}'[n] - n\\times V_{LSB}' - V_{OUT}'[0]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-1] \\hspace{10 pt} (6) $$ where $V_{OUT}'[n]$ is the output voltage of the real DAC at the $n^{th}$ transition and $V_{LSB}'$ is the measured step size of the non-ideal DAC. NOTE: The INL and DNL can only be calculated after removing the linear error sources (offset, and gain errors). # measure the real vlsb vlsb_measured = ( vout_nonlinear [ 2 ** n_bits - 1 ] - vout_nonlinear [ 0 ]) / ( 2 ** n_bits - 1 ) print ( \"The ideal vlsb is \" + \" {:.4f} V\" . format ( vlsb )) print ( \"The measured vlsb is \" + \" {:.4f} V\" . format ( vlsb_measured )) # measure the DNL of the DAC dnl = ( vout_nonlinear [ 1 ::] - vout_nonlinear [ 0 : - 1 ]) / vlsb_measured - 1 dnl_pythonic = np . diff ( vout_nonlinear ) / vlsb_measured - 1 assert np . allclose ( dnl , dnl_pythonic ), \"The DNL two methods give different results\" # assert that n is in [0, 2**n_bits-2] for the DNL assert len ( dnl ) == 2 ** n_bits - 1 , \"The DNL has a wrong length\" idx = np . arange ( 2 ** n_bits ) inl = ( vout_nonlinear - idx * vlsb_measured - vout_nonlinear [ 0 ]) / vlsb_measured # assert that n is in [0, 2**n_bits-1] for the INL assert len ( inl ) == 2 ** n_bits , \"The INL has a wrong length\" # plot the results fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) ax [ 0 ] . plot ( din [ 1 ::], dnl , label = \"DNL\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax [ 1 ] . plot ( din , inl , label = \"INL\" , marker = \"None\" , mfc = \"None\" , color = \"r\" ) ax [ 0 ] . set_xlabel ( \"Input code\" ) ax [ 1 ] . set_xlabel ( \"Input code\" ) ax [ 0 ] . set_ylabel ( \"DNL\" ) ax [ 1 ] . set_ylabel ( \"INL\" ) ax [ 0 ] . set_title ( \"DAC Non-Linearity\" ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) fig . tight_layout () fig . legend ( fancybox = False , frameon = False , fontsize = 8 ) The ideal vlsb is 0.0625 V The measured vlsb is 0.0632 V <matplotlib.legend.Legend at 0x134f82090>","title":"DAC Non-Linear Errors"},{"location":"signal_converters/#adc-error-modelling","text":"","title":"ADC Error Modelling"},{"location":"signal_converters/#adc-linear-errors","text":"This section presents the modelling of the linear errors that arise when modelling the transfer function of a ADC. These errors relate to a deviation of the real transfer function of the ADC towards the ideal ADC's transfer function, in which each step size is exactly the same width! It is important to note that in this case (ADC), it is the transition voltlallges of the ADC that deviate from ideal ones, without ever changing step size! # define the ADC vref = 1.0 # define the reference voltage [V] n_bits = 4 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels # define an ideal DAC to compare the results roundf = np . round iadc = ideal_adc ( vref , n_bits , roundf ) # define the non-ideal ADC with linear errors # to procees with this step, we need to define # an ADC modelling function that is closer to the # its physical implementation - the model should include # the transition voltages as a characteristic parameter # and the input voltage will only provoke a transition # if the input voltage is greater than the corresponding # transition voltage # define an ADC with offset error voff = 0.05 adc_off , vt_off = nonideal_adc ( vref , n_bits , roundf = roundf , ofst = voff ) # define a ADC with end of scale error # note that the end of scale error # is actually directly related to # the gain error of the ADC # The gain error of the ADC is directly related to the # VREF voltage variation of the ADC. The lower the VREF # the lower will be vlsb, and as such, the higher will be # the end of scale error once the gain decreases. The # reciprocal is also true, the higher the VREF the higher # will be the Vlsb, and as such, the higher will be the # the gain of the ADC. vref_err = - 0.05 # -5% Vref variation true_vref = ( 1 + vref_err ) * vref adc_eos , vt_eos = nonideal_adc ( true_vref , n_bits , roundf = roundf ) # define a DAC with offset and end of scale error # to measure the true DAC gain error adc_off_eos , vt_off_eos = nonideal_adc ( true_vref , n_bits , roundf = roundf , ofst = voff ) # define the input voltages of the ADC vin = np . arange ( 0 , vref , vlsb ) vt_off = np . concatenate (([ 0 ], vt_off )) vt_eos = np . concatenate (([ 0 ], vt_eos )) vt_off_eos = np . concatenate (([ 0 ], vt_off_eos )) # create the string representation of the input codes # compute the output voltages of the 3 DACs dout = iadc ( vin ) dout_off = adc_off ( vin ) dout_eos = adc_eos ( vin ) dout_off_eos = adc_off_eos ( vin ) # convert the output codes to decimals dout_dec = bin2dec ( dout , n_bits ) dout_off_dec = bin2dec ( dout_off , n_bits ) dout_eos_dec = bin2dec ( dout_eos , n_bits ) dout_off_eos_dec = bin2dec ( dout_off_eos , n_bits ) # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 8 )) ax . plot ( vin , dout_dec , label = \"Ideal ADC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax . step ( vt_off , dout_off_dec , where = \"post\" , label = \"ADC with offset error\" , color = \"b\" ) ax . step ( vt_eos , dout_eos_dec , where = \"post\" , label = \"ADC with end of scale error\" , color = \"r\" ) ax . step ( vt_off_eos , dout_off_eos_dec , where = \"post\" , label = \"ADC with offset and end of scale error\" , color = \"g\" ) ax . set_xlabel ( \"Input voltage [V]\" ) ax . set_ylabel ( \"Output code\" ) ax . set_title ( \"ADC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) ax . grid ( True ) fig . tight_layout () # compute linear error ratios e_off = ( vout_off_eos [ 0 ] - vin [ 0 ]) / vlsb e_eos = ( vout_off_eos [ - 1 ] - vin [ - 1 ]) / vlsb ger_pct = (( vout_off_eos [ - 1 ] - vout_off_eos [ 0 ]) / ( vin [ - 1 ] - vin [ 0 ]) - 1 ) * 100 print ( \"The offset error is \" + \" {:.2f} LSB\" . format ( e_off )) print ( \"The end of scale error is \" + \" {:.2f} LSB\" . format ( e_eos )) print ( \"The gain error is \" + \" {:.2f} %\" . format ( ger_pct )) The offset error is 0 . 80 LSB The end of scale error is - 0 . 25 LSB The gain error is - 7 . 00 %","title":"ADC Linear Errors"},{"location":"signal_converters/#adc-non-linear-errors","text":"This section presents the modelling of the non-linear errors that arise when modelling the transfer function of a ADC. These errors relate to a deviation of the real transfer function of the ADC towards the ideal ADC's transfer function, in which each step size can differ in width due to the inherent non-linearity that arises when quantizing a noisy signal! In a physical implementation, the intrinsic non-linearities that devices present are usually the main source of non-linear errors in ADCs, directly affecting the position of the transition voltages of the ADC. # define the ADC vref = 1.0 # define the reference voltage [V] n_bits = 5 # define the number of bits of the DAC vlsb = vref / ( 2 ** n_bits ) # compute the fundamental step voltage between quantized levels roundf = np . round # define an ideal DAC to compare the results iadc = ideal_adc ( vref , n_bits , roundf ) # define the noise signal with a uniform distribution vq_var = ( vlsb ** 2 ) / 12 vq_std_dev = np . sqrt ( vq_var ) noise_factor = 2 adc_nonlinear , vtrans = nonideal_adc ( vref , n_bits , roundf = roundf , vnq = noise_factor * vq_std_dev ) # define the input voltages of the ADC vin = np . arange ( 0 , vref , vlsb ) # compute the output codes of the ADC dout = bin2dec ( iadc ( vin ), n_bits ) dout_nonlinear = bin2dec ( adc_nonlinear ( vin ), n_bits ) # plot the results fig , ax = plt . subplots ( 1 , 1 , figsize = ( 10 , 8 )) ax . plot ( vin , dout , label = \"Ideal ADC\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax . step ( vin , dout_nonlinear , where = \"post\" , label = \"non-linear ADC\" , color = \"r\" ) ax . set_xlabel ( \"Input voltage [V]\" ) ax . set_ylabel ( \"Output code\" ) ax . set_title ( \"ADC Transfer Function\" ) ax . legend ( fontsize = 14 , fancybox = False , frameon = False ) ax . grid ( True ) fig . tight_layout () From both figures observed in this ADC section (2.1 and 2.2), a very important conclusion can be taken: both linear and non-linear errors can lead to missing codes in the output of the ADC, which eventually leads to a loss of effective resolution of the converter. Analogously to the DAC section, the non-linear errors of converters can come in two forms: Differential Non-Linearity (DNL), given in Eq.(8), Integral Non-Linearity (INL), given in Eq.(9). The DNL and INL are measured in LSB units. The DNL provides a method of locally observing how much each step size changes in each transition voltage. The INL on the other hand is the accumulation of the DNL up until the respective transition, and enables the measurement of the global transition voltage step-size variability throughout every transition of the transfer function. In ADCs, the INL and DNL, as well as any other kind of error, are measured in the horizontal axis, where the voltage unit is. Eq. (7) presents the actual measured least significant bit step voltage of the ADC. $$ V_{LSB}' = \\frac{V_{T}'[2^N - 1] - V_{T}'[1]}{2^N - 2} \\hspace{4 pt} [V] \\hspace{10 pt} (7) $$ $$ DNL[n] = \\frac{V_{T}'[n+1] - V_{T}'[n]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-3] \\hspace{10 pt} (8) $$ $$ INL[n] = \\frac{V_{T}'[n] - n\\times V_{LSB}' - V_{T}'[1]}{V_{LSB}'} \\hspace{4 pt} [LSB], n\\in [0, 2^N-2] \\hspace{10 pt} (9) $$ where $V_{T}'[n]$ is the transition voltage level of the real ADC at the $n^{th}$ transition and $V_{LSB}'$ is the measured least significant bit step size of the non-ideal ADC. In this case (ADC), there are $2^N$ intervals, but only $2^N - 1$ transition voltages, whereas in the DAC case there are $2^N$ intervals and $2^N$ output voltages NOTE: The INL and DNL can only be calculated after removing the linear error sources (offset, and gain errors). # compute the non linearity of the ADC # compute the measured vlsb assert len ( vtrans ) == 2 ** n_bits - 1 vlsb_measured = ( vtrans [ - 1 ] - vtrans [ 0 ]) / ( len ( vtrans ) - 1 ) print ( \"The ideal vlsb is \" + \" {:.4f} V\" . format ( vlsb )) print ( \"The measured vlsb is \" + \" {:.4f} V\" . format ( vlsb_measured )) # compute the DNL dnl = np . diff ( vtrans ) / vlsb_measured - 1 # assert that n is in [0, 2**n_bits-3] for the DNL assert len ( dnl ) == 2 ** n_bits - 2 , \"The number of DNL values is not correct\" # compute the INL idx = np . arange ( 0 , len ( vtrans ), 1 ) inl = ( vtrans - idx * vlsb_measured - vtrans [ 0 ]) / vlsb_measured # assert that n is in [0, 2**n_bits-2] for the INL assert len ( inl ) == 2 ** n_bits - 1 , \"The number of INL values is not correct\" The ideal vlsb is 0.0312 V The measured vlsb is 0.0319 V codes = np . arange ( 1 , len ( vtrans ), 1 ) # define the DNL transition codes # plot the results fig , ax = plt . subplots ( 2 , 1 , figsize = ( 10 , 5 )) ax [ 0 ] . plot ( codes , dnl , label = \"DNL\" , marker = \"None\" , mfc = \"None\" , color = \"k\" ) ax [ 1 ] . plot ( idx , inl , label = \"INL\" , marker = \"None\" , mfc = \"None\" , color = \"r\" ) ax [ 0 ] . set_xlabel ( \"Code\" ) ax [ 0 ] . set_ylabel ( \"DNL\" ) ax [ 1 ] . set_xlabel ( \"Code\" ) ax [ 1 ] . set_ylabel ( \"INL\" ) ax [ 0 ] . set_title ( \"DNL and INL\" ) ax [ 0 ] . legend ( fontsize = 8 , fancybox = False , frameon = False ) ax [ 1 ] . legend ( fontsize = 8 , fancybox = False , frameon = False ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) fig . tight_layout ()","title":"ADC Non-Linear Errors"}]}